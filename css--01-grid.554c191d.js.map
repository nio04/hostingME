{"mappings":"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","sources":["<anon>","src/js/prism.js"],"sourcesContent":["/* PrismJS 1.29.0\nhttps://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript+css-extras+git+regex+scss&plugins=line-numbers+previewers+normalize-whitespace+toolbar+copy-to-clipboard+match-braces */ /// <reference lib=\"WebWorker\"/>\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nvar _self = typeof window !== \"undefined\" ? window // if in browser\n : typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope ? self // if in worker\n : {} // if in node js\n;\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */ var Prism = function(_self) {\n    // Private helper vars\n    var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n    var uniqueId = 0;\n    // The grammar object for plaintext\n    var plainTextGrammar = {};\n    var _ = {\n        /**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ manual: _self.Prism && _self.Prism.manual,\n        /**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n        /**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */ util: {\n            encode: function encode(tokens) {\n                if (tokens instanceof Token) return new Token(tokens.type, encode(tokens.content), tokens.alias);\n                else if (Array.isArray(tokens)) return tokens.map(encode);\n                else return tokens.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n            },\n            /**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */ type: function type(o) {\n                return Object.prototype.toString.call(o).slice(8, -1);\n            },\n            /**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */ objId: function objId(obj) {\n                if (!obj[\"__id\"]) Object.defineProperty(obj, \"__id\", {\n                    value: ++uniqueId\n                });\n                return obj[\"__id\"];\n            },\n            /**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */ clone: function deepClone(o, visited) {\n                visited = visited || {};\n                var clone;\n                var id;\n                switch(_.util.type(o)){\n                    case \"Object\":\n                        id = _.util.objId(o);\n                        if (visited[id]) return visited[id];\n                        clone = /** @type {Record<string, any>} */ {};\n                        visited[id] = clone;\n                        for(var key in o)if (o.hasOwnProperty(key)) clone[key] = deepClone(o[key], visited);\n                        return /** @type {any} */ clone;\n                    case \"Array\":\n                        id = _.util.objId(o);\n                        if (visited[id]) return visited[id];\n                        clone = [];\n                        visited[id] = clone;\n                        /** @type {Array} */ /** @type {any} */ o.forEach(function(v, i) {\n                            clone[i] = deepClone(v, visited);\n                        });\n                        return /** @type {any} */ clone;\n                    default:\n                        return o;\n                }\n            },\n            /**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */ getLanguage: function getLanguage(element) {\n                while(element){\n                    var m = lang.exec(element.className);\n                    if (m) return m[1].toLowerCase();\n                    element = element.parentElement;\n                }\n                return \"none\";\n            },\n            /**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */ setLanguage: function setLanguage(element, language) {\n                // remove all `language-xxxx` classes\n                // (this might leave behind a leading space)\n                element.className = element.className.replace(RegExp(lang, \"gi\"), \"\");\n                // add the new `language-xxxx` class\n                // (using `classList` will automatically clean up spaces for us)\n                element.classList.add(\"language-\" + language);\n            },\n            /**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */ currentScript: function currentScript() {\n                if (typeof document === \"undefined\") return null;\n                if (\"currentScript\" in document && true /* hack to trip TS' flow analysis */ ) return /** @type {any} */ document.currentScript;\n                // IE11 workaround\n                // we'll get the src of the current script by parsing IE11's error stack trace\n                // this will not work for inline scripts\n                try {\n                    throw new Error();\n                } catch (err) {\n                    // Get file src url from stack. Specifically works with the format of stack traces in IE.\n                    // A stack will look like this:\n                    //\n                    // Error\n                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n                    //    at Global code (http://localhost/components/prism-core.js:606:1)\n                    var src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n                    if (src) {\n                        var scripts = document.getElementsByTagName(\"script\");\n                        for(var i in scripts){\n                            if (scripts[i].src == src) return scripts[i];\n                        }\n                    }\n                    return null;\n                }\n            },\n            /**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */ isActive: function isActive(element, className, defaultActivation) {\n                var no = \"no-\" + className;\n                while(element){\n                    var classList = element.classList;\n                    if (classList.contains(className)) return true;\n                    if (classList.contains(no)) return false;\n                    element = element.parentElement;\n                }\n                return !!defaultActivation;\n            }\n        },\n        /**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ languages: {\n            /**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */ plain: plainTextGrammar,\n            plaintext: plainTextGrammar,\n            text: plainTextGrammar,\n            txt: plainTextGrammar,\n            /**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */ extend: function extend(id, redef) {\n                var lang = _.util.clone(_.languages[id]);\n                for(var key in redef)lang[key] = redef[key];\n                return lang;\n            },\n            /**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */ insertBefore: function insertBefore(inside, before, insert, root) {\n                root = root || /** @type {any} */ _.languages;\n                var grammar = root[inside];\n                /** @type {Grammar} */ var ret = {};\n                for(var token in grammar)if (grammar.hasOwnProperty(token)) {\n                    if (token == before) {\n                        for(var newToken in insert)if (insert.hasOwnProperty(newToken)) ret[newToken] = insert[newToken];\n                    }\n                    // Do not insert token which also occur in insert. See #1525\n                    if (!insert.hasOwnProperty(token)) ret[token] = grammar[token];\n                }\n                var old = root[inside];\n                root[inside] = ret;\n                // Update references in other language definitions\n                _.languages.DFS(_.languages, function(key, value) {\n                    if (value === old && key != inside) this[key] = ret;\n                });\n                return ret;\n            },\n            // Traverse a language definition with Depth First Search\n            DFS: function DFS(o, callback, type, visited) {\n                visited = visited || {};\n                var objId = _.util.objId;\n                for(var i in o)if (o.hasOwnProperty(i)) {\n                    callback.call(o, i, o[i], type || i);\n                    var property = o[i];\n                    var propertyType = _.util.type(property);\n                    if (propertyType === \"Object\" && !visited[objId(property)]) {\n                        visited[objId(property)] = true;\n                        DFS(property, callback, null, visited);\n                    } else if (propertyType === \"Array\" && !visited[objId(property)]) {\n                        visited[objId(property)] = true;\n                        DFS(property, callback, i, visited);\n                    }\n                }\n            }\n        },\n        plugins: {},\n        /**\n\t\t * This is the most high-level function in Prism’s API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ highlightAll: function highlightAll(async, callback) {\n            _.highlightAllUnder(document, async, callback);\n        },\n        /**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ highlightAllUnder: function highlightAllUnder(container, async, callback) {\n            var env = {\n                callback: callback,\n                container: container,\n                selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n            };\n            _.hooks.run(\"before-highlightall\", env);\n            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n            _.hooks.run(\"before-all-elements-highlight\", env);\n            for(var i = 0, element; element = env.elements[i++];)_.highlightElement(element, async === true, env.callback);\n        },\n        /**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ highlightElement: function highlightElement(element, async, callback) {\n            // Find language\n            var language = _.util.getLanguage(element);\n            var grammar = _.languages[language];\n            // Set language on the element, if not present\n            _.util.setLanguage(element, language);\n            // Set language on the parent, for styling\n            var parent = element.parentElement;\n            if (parent && parent.nodeName.toLowerCase() === \"pre\") _.util.setLanguage(parent, language);\n            var code = element.textContent;\n            var env = {\n                element: element,\n                language: language,\n                grammar: grammar,\n                code: code\n            };\n            function insertHighlightedCode(highlightedCode) {\n                env.highlightedCode = highlightedCode;\n                _.hooks.run(\"before-insert\", env);\n                env.element.innerHTML = env.highlightedCode;\n                _.hooks.run(\"after-highlight\", env);\n                _.hooks.run(\"complete\", env);\n                callback && callback.call(env.element);\n            }\n            _.hooks.run(\"before-sanity-check\", env);\n            // plugins may change/add the parent/element\n            parent = env.element.parentElement;\n            if (parent && parent.nodeName.toLowerCase() === \"pre\" && !parent.hasAttribute(\"tabindex\")) parent.setAttribute(\"tabindex\", \"0\");\n            if (!env.code) {\n                _.hooks.run(\"complete\", env);\n                callback && callback.call(env.element);\n                return;\n            }\n            _.hooks.run(\"before-highlight\", env);\n            if (!env.grammar) {\n                insertHighlightedCode(_.util.encode(env.code));\n                return;\n            }\n            if (async && _self.Worker) {\n                var worker = new Worker(_.filename);\n                worker.onmessage = function(evt) {\n                    insertHighlightedCode(evt.data);\n                };\n                worker.postMessage(JSON.stringify({\n                    language: env.language,\n                    code: env.code,\n                    immediateClose: true\n                }));\n            } else insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n        },\n        /**\n\t\t * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */ highlight: function highlight(text, grammar, language) {\n            var env = {\n                code: text,\n                grammar: grammar,\n                language: language\n            };\n            _.hooks.run(\"before-tokenize\", env);\n            if (!env.grammar) throw new Error('The language \"' + env.language + '\" has no grammar.');\n            env.tokens = _.tokenize(env.code, env.grammar);\n            _.hooks.run(\"after-tokenize\", env);\n            return Token.stringify(_.util.encode(env.tokens), env.language);\n        },\n        /**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */ tokenize: function tokenize(text, grammar) {\n            var rest = grammar.rest;\n            if (rest) {\n                for(var token in rest)grammar[token] = rest[token];\n                delete grammar.rest;\n            }\n            var tokenList = new LinkedList();\n            addAfter(tokenList, tokenList.head, text);\n            matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n            return toArray(tokenList);\n        },\n        /**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */ hooks: {\n            all: {},\n            /**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */ add: function add(name, callback) {\n                var hooks = _.hooks.all;\n                hooks[name] = hooks[name] || [];\n                hooks[name].push(callback);\n            },\n            /**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */ run: function run(name, env) {\n                var callbacks = _.hooks.all[name];\n                if (!callbacks || !callbacks.length) return;\n                for(var i = 0, callback; callback = callbacks[i++];)callback(env);\n            }\n        },\n        Token: Token\n    };\n    _self.Prism = _;\n    // Typescript note:\n    // The following can be used to import the Token type in JSDoc:\n    //\n    //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n    /**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */ function Token(type, content, alias, matchedStr) {\n        /**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */ this.type = type;\n        /**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */ this.content = content;\n        /**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */ this.alias = alias;\n        // Copy of the full string this token was created from\n        this.length = (matchedStr || \"\").length | 0;\n    }\n    /**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */ /**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */ Token.stringify = function stringify(o, language) {\n        if (typeof o == \"string\") return o;\n        if (Array.isArray(o)) {\n            var s = \"\";\n            o.forEach(function(e) {\n                s += stringify(e, language);\n            });\n            return s;\n        }\n        var env = {\n            type: o.type,\n            content: stringify(o.content, language),\n            tag: \"span\",\n            classes: [\n                \"token\",\n                o.type\n            ],\n            attributes: {},\n            language: language\n        };\n        var aliases = o.alias;\n        if (aliases) {\n            if (Array.isArray(aliases)) Array.prototype.push.apply(env.classes, aliases);\n            else env.classes.push(aliases);\n        }\n        _.hooks.run(\"wrap\", env);\n        var attributes = \"\";\n        for(var name in env.attributes)attributes += \" \" + name + '=\"' + (env.attributes[name] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n        return \"<\" + env.tag + ' class=\"' + env.classes.join(\" \") + '\"' + attributes + \">\" + env.content + \"</\" + env.tag + \">\";\n    };\n    /**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */ function matchPattern(pattern, pos, text, lookbehind) {\n        pattern.lastIndex = pos;\n        var match = pattern.exec(text);\n        if (match && lookbehind && match[1]) {\n            // change the match to remove the text matched by the Prism lookbehind group\n            var lookbehindLength = match[1].length;\n            match.index += lookbehindLength;\n            match[0] = match[0].slice(lookbehindLength);\n        }\n        return match;\n    }\n    /**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n        for(var token in grammar){\n            if (!grammar.hasOwnProperty(token) || !grammar[token]) continue;\n            var patterns = grammar[token];\n            patterns = Array.isArray(patterns) ? patterns : [\n                patterns\n            ];\n            for(var j = 0; j < patterns.length; ++j){\n                if (rematch && rematch.cause == token + \",\" + j) return;\n                var patternObj = patterns[j];\n                var inside = patternObj.inside;\n                var lookbehind = !!patternObj.lookbehind;\n                var greedy = !!patternObj.greedy;\n                var alias = patternObj.alias;\n                if (greedy && !patternObj.pattern.global) {\n                    // Without the global flag, lastIndex won't work\n                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + \"g\");\n                }\n                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;\n                for(var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){\n                    if (rematch && pos >= rematch.reach) break;\n                    var str = currentNode.value;\n                    if (tokenList.length > text.length) // Something went terribly wrong, ABORT, ABORT!\n                    return;\n                    if (str instanceof Token) continue;\n                    var removeCount = 1; // this is the to parameter of removeBetween\n                    var match;\n                    if (greedy) {\n                        match = matchPattern(pattern, pos, text, lookbehind);\n                        if (!match || match.index >= text.length) break;\n                        var from = match.index;\n                        var to = match.index + match[0].length;\n                        var p = pos;\n                        // find the node that contains the match\n                        p += currentNode.value.length;\n                        while(from >= p){\n                            currentNode = currentNode.next;\n                            p += currentNode.value.length;\n                        }\n                        // adjust pos (and p)\n                        p -= currentNode.value.length;\n                        pos = p;\n                        // the current node is a Token, then the match starts inside another Token, which is invalid\n                        if (currentNode.value instanceof Token) continue;\n                        // find the last node which is affected by this match\n                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === \"string\"); k = k.next){\n                            removeCount++;\n                            p += k.value.length;\n                        }\n                        removeCount--;\n                        // replace with the new match\n                        str = text.slice(pos, p);\n                        match.index -= pos;\n                    } else {\n                        match = matchPattern(pattern, 0, str, lookbehind);\n                        if (!match) continue;\n                    }\n                    // eslint-disable-next-line no-redeclare\n                    var from = match.index;\n                    var matchStr = match[0];\n                    var before = str.slice(0, from);\n                    var after = str.slice(from + matchStr.length);\n                    var reach = pos + str.length;\n                    if (rematch && reach > rematch.reach) rematch.reach = reach;\n                    var removeFrom = currentNode.prev;\n                    if (before) {\n                        removeFrom = addAfter(tokenList, removeFrom, before);\n                        pos += before.length;\n                    }\n                    removeRange(tokenList, removeFrom, removeCount);\n                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n                    currentNode = addAfter(tokenList, removeFrom, wrapped);\n                    if (after) addAfter(tokenList, currentNode, after);\n                    if (removeCount > 1) {\n                        // at least one Token object was removed, so we have to do some rematching\n                        // this can only happen if the current pattern is greedy\n                        /** @type {RematchOptions} */ var nestedRematch = {\n                            cause: token + \",\" + j,\n                            reach: reach\n                        };\n                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n                        // the reach might have been extended because of the rematching\n                        if (rematch && nestedRematch.reach > rematch.reach) rematch.reach = nestedRematch.reach;\n                    }\n                }\n            }\n        }\n    }\n    /**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */ /**\n\t * @template T\n\t * @private\n\t */ function LinkedList() {\n        /** @type {LinkedListNode<T>} */ var head = {\n            value: null,\n            prev: null,\n            next: null\n        };\n        /** @type {LinkedListNode<T>} */ var tail = {\n            value: null,\n            prev: head,\n            next: null\n        };\n        head.next = tail;\n        /** @type {LinkedListNode<T>} */ this.head = head;\n        /** @type {LinkedListNode<T>} */ this.tail = tail;\n        this.length = 0;\n    }\n    /**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */ function addAfter(list, node, value) {\n        // assumes that node != list.tail && values.length >= 0\n        var next = node.next;\n        var newNode = {\n            value: value,\n            prev: node,\n            next: next\n        };\n        node.next = newNode;\n        next.prev = newNode;\n        list.length++;\n        return newNode;\n    }\n    /**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */ function removeRange(list, node, count) {\n        var next = node.next;\n        for(var i = 0; i < count && next !== list.tail; i++)next = next.next;\n        node.next = next;\n        next.prev = node;\n        list.length -= i;\n    }\n    /**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */ function toArray(list) {\n        var array = [];\n        var node = list.head.next;\n        while(node !== list.tail){\n            array.push(node.value);\n            node = node.next;\n        }\n        return array;\n    }\n    if (!_self.document) {\n        if (!_self.addEventListener) // in Node.js\n        return _;\n        if (!_.disableWorkerMessageHandler) // In worker\n        _self.addEventListener(\"message\", function(evt) {\n            var message = JSON.parse(evt.data);\n            var lang = message.language;\n            var code = message.code;\n            var immediateClose = message.immediateClose;\n            _self.postMessage(_.highlight(code, _.languages[lang], lang));\n            if (immediateClose) _self.close();\n        }, false);\n        return _;\n    }\n    // Get current script and highlight\n    var script = _.util.currentScript();\n    if (script) {\n        _.filename = script.src;\n        if (script.hasAttribute(\"data-manual\")) _.manual = true;\n    }\n    function highlightAutomaticallyCallback() {\n        if (!_.manual) _.highlightAll();\n    }\n    if (!_.manual) {\n        // If the document state is \"loading\", then we'll use DOMContentLoaded.\n        // If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n        // might take longer one animation frame to execute which can create a race condition where only some plugins have\n        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n        // See https://github.com/PrismJS/prism/issues/2102\n        var readyState = document.readyState;\n        if (readyState === \"loading\" || readyState === \"interactive\" && script && script.defer) document.addEventListener(\"DOMContentLoaded\", highlightAutomaticallyCallback);\n        else if (window.requestAnimationFrame) window.requestAnimationFrame(highlightAutomaticallyCallback);\n        else window.setTimeout(highlightAutomaticallyCallback, 16);\n    }\n    return _;\n}(_self);\nif (typeof module !== \"undefined\" && module.exports) module.exports = Prism;\n// hack for components to work correctly in node.js\nif (typeof global !== \"undefined\") global.Prism = Prism;\n /**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */ \nPrism.languages.markup = {\n    \"comment\": {\n        pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n        greedy: true\n    },\n    \"prolog\": {\n        pattern: /<\\?[\\s\\S]+?\\?>/,\n        greedy: true\n    },\n    \"doctype\": {\n        // https://www.w3.org/TR/xml/#NT-doctypedecl\n        pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n        greedy: true,\n        inside: {\n            \"internal-subset\": {\n                pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n                lookbehind: true,\n                greedy: true,\n                inside: null // see below\n            },\n            \"string\": {\n                pattern: /\"[^\"]*\"|'[^']*'/,\n                greedy: true\n            },\n            \"punctuation\": /^<!|>$|[[\\]]/,\n            \"doctype-tag\": /^DOCTYPE/i,\n            \"name\": /[^\\s<>'\"]+/\n        }\n    },\n    \"cdata\": {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        greedy: true\n    },\n    \"tag\": {\n        pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n        greedy: true,\n        inside: {\n            \"tag\": {\n                pattern: /^<\\/?[^\\s>\\/]+/,\n                inside: {\n                    \"punctuation\": /^<\\/?/,\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            },\n            \"special-attr\": [],\n            \"attr-value\": {\n                pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n                inside: {\n                    \"punctuation\": [\n                        {\n                            pattern: /^=/,\n                            alias: \"attr-equals\"\n                        },\n                        {\n                            pattern: /^(\\s*)[\"']|[\"']$/,\n                            lookbehind: true\n                        }\n                    ]\n                }\n            },\n            \"punctuation\": /\\/?>/,\n            \"attr-name\": {\n                pattern: /[^\\s>\\/]+/,\n                inside: {\n                    \"namespace\": /^[^\\s>\\/:]+:/\n                }\n            }\n        }\n    },\n    \"entity\": [\n        {\n            pattern: /&[\\da-z]{1,8};/i,\n            alias: \"named-entity\"\n        },\n        /&#x?[\\da-f]{1,8};/i\n    ]\n};\nPrism.languages.markup[\"tag\"].inside[\"attr-value\"].inside[\"entity\"] = Prism.languages.markup[\"entity\"];\nPrism.languages.markup[\"doctype\"].inside[\"internal-subset\"].inside = Prism.languages.markup;\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add(\"wrap\", function(env) {\n    if (env.type === \"entity\") env.attributes[\"title\"] = env.content.replace(/&amp;/, \"&\");\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addInlined\", {\n    /**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */ value: function addInlined(tagName, lang) {\n        var includedCdataInside = {};\n        includedCdataInside[\"language-\" + lang] = {\n            pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n            lookbehind: true,\n            inside: Prism.languages[lang]\n        };\n        includedCdataInside[\"cdata\"] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n        var inside = {\n            \"included-cdata\": {\n                pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n                inside: includedCdataInside\n            }\n        };\n        inside[\"language-\" + lang] = {\n            pattern: /[\\s\\S]+/,\n            inside: Prism.languages[lang]\n        };\n        var def = {};\n        def[tagName] = {\n            pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n                return tagName;\n            }), \"i\"),\n            lookbehind: true,\n            greedy: true,\n            inside: inside\n        };\n        Prism.languages.insertBefore(\"markup\", \"cdata\", def);\n    }\n});\nObject.defineProperty(Prism.languages.markup.tag, \"addAttribute\", {\n    /**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */ value: function value(attrName, lang) {\n        Prism.languages.markup.tag.inside[\"special-attr\"].push({\n            pattern: RegExp(/(^|[\"'\\s])/.source + \"(?:\" + attrName + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, \"i\"),\n            lookbehind: true,\n            inside: {\n                \"attr-name\": /^[^\\s=]+/,\n                \"attr-value\": {\n                    pattern: /=[\\s\\S]+/,\n                    inside: {\n                        \"value\": {\n                            pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                            lookbehind: true,\n                            alias: [\n                                lang,\n                                \"language-\" + lang\n                            ],\n                            inside: Prism.languages[lang]\n                        },\n                        \"punctuation\": [\n                            {\n                                pattern: /^=/,\n                                alias: \"attr-equals\"\n                            },\n                            /\"|'/\n                        ]\n                    }\n                }\n            }\n        });\n    }\n});\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\nPrism.languages.xml = Prism.languages.extend(\"markup\", {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n(function(Prism) {\n    var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    Prism.languages.css = {\n        \"comment\": /\\/\\*[\\s\\S]*?\\*\\//,\n        \"atrule\": {\n            pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + string.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n            inside: {\n                \"rule\": /^@[\\w-]+/,\n                \"selector-function-argument\": {\n                    pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n                    lookbehind: true,\n                    alias: \"selector\"\n                },\n                \"keyword\": {\n                    pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n                    lookbehind: true\n                }\n            }\n        },\n        \"url\": {\n            // https://drafts.csswg.org/css-values-3/#urls\n            pattern: RegExp(\"\\\\burl\\\\((?:\" + string.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n            greedy: true,\n            inside: {\n                \"function\": /^url/i,\n                \"punctuation\": /^\\(|\\)$/,\n                \"string\": {\n                    pattern: RegExp(\"^\" + string.source + \"$\"),\n                    alias: \"url\"\n                }\n            }\n        },\n        \"selector\": {\n            pattern: RegExp(\"(^|[{}\\\\s])[^{}\\\\s](?:[^{};\\\"'\\\\s]|\\\\s+(?![\\\\s{])|\" + string.source + \")*(?=\\\\s*\\\\{)\"),\n            lookbehind: true\n        },\n        \"string\": {\n            pattern: string,\n            greedy: true\n        },\n        \"property\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n            lookbehind: true\n        },\n        \"important\": /!important\\b/i,\n        \"function\": {\n            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n            lookbehind: true\n        },\n        \"punctuation\": /[(){};:,]/\n    };\n    Prism.languages.css[\"atrule\"].inside.rest = Prism.languages.css;\n    var markup = Prism.languages.markup;\n    if (markup) {\n        markup.tag.addInlined(\"style\", \"css\");\n        markup.tag.addAttribute(\"style\", \"css\");\n    }\n})(Prism);\nPrism.languages.clike = {\n    \"comment\": [\n        {\n            pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n            lookbehind: true,\n            greedy: true\n        },\n        {\n            pattern: /(^|[^\\\\:])\\/\\/.*/,\n            lookbehind: true,\n            greedy: true\n        }\n    ],\n    \"string\": {\n        pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n        greedy: true\n    },\n    \"class-name\": {\n        pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n        lookbehind: true,\n        inside: {\n            \"punctuation\": /[.\\\\]/\n        }\n    },\n    \"keyword\": /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"function\": /\\b\\w+(?=\\()/,\n    \"number\": /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    \"operator\": /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    \"punctuation\": /[{}[\\];(),.:]/\n};\nPrism.languages.javascript = Prism.languages.extend(\"clike\", {\n    \"class-name\": [\n        Prism.languages.clike[\"class-name\"],\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n            lookbehind: true\n        }\n    ],\n    \"keyword\": [\n        {\n            pattern: /((?:^|\\})\\s*)catch\\b/,\n            lookbehind: true\n        },\n        {\n            pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n            lookbehind: true\n        }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    \"function\": /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    \"number\": {\n        pattern: RegExp(/(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source),\n        lookbehind: true\n    },\n    \"operator\": /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nPrism.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nPrism.languages.insertBefore(\"javascript\", \"keyword\", {\n    \"regex\": {\n        pattern: RegExp(// lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n            \"regex-source\": {\n                pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n                lookbehind: true,\n                alias: \"language-regex\",\n                inside: Prism.languages.regex\n            },\n            \"regex-delimiter\": /^\\/|\\/$/,\n            \"regex-flags\": /^[a-z]+$/\n        }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n        pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n        alias: \"function\"\n    },\n    \"parameter\": [\n        {\n            pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        },\n        {\n            pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n            lookbehind: true,\n            inside: Prism.languages.javascript\n        }\n    ],\n    \"constant\": /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nPrism.languages.insertBefore(\"javascript\", \"string\", {\n    \"hashbang\": {\n        pattern: /^#!.*/,\n        greedy: true,\n        alias: \"comment\"\n    },\n    \"template-string\": {\n        pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n        greedy: true,\n        inside: {\n            \"template-punctuation\": {\n                pattern: /^`|`$/,\n                alias: \"string\"\n            },\n            \"interpolation\": {\n                pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n                lookbehind: true,\n                inside: {\n                    \"interpolation-punctuation\": {\n                        pattern: /^\\$\\{|\\}$/,\n                        alias: \"punctuation\"\n                    },\n                    rest: Prism.languages.javascript\n                }\n            },\n            \"string\": /[\\s\\S]+/\n        }\n    },\n    \"string-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n        lookbehind: true,\n        greedy: true,\n        alias: \"property\"\n    }\n});\nPrism.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n        pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n        lookbehind: true,\n        alias: \"property\"\n    }\n});\nif (Prism.languages.markup) {\n    Prism.languages.markup.tag.addInlined(\"script\", \"javascript\");\n    // add attribute support for all DOM events.\n    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, \"javascript\");\n}\nPrism.languages.js = Prism.languages.javascript;\n(function(Prism) {\n    var string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n    var selectorInside;\n    Prism.languages.css.selector = {\n        pattern: Prism.languages.css.selector.pattern,\n        lookbehind: true,\n        inside: selectorInside = {\n            \"pseudo-element\": /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n            \"pseudo-class\": /:[-\\w]+/,\n            \"class\": /\\.[-\\w]+/,\n            \"id\": /#[-\\w]+/,\n            \"attribute\": {\n                pattern: RegExp(\"\\\\[(?:[^[\\\\]\\\"']|\" + string.source + \")*\\\\]\"),\n                greedy: true,\n                inside: {\n                    \"punctuation\": /^\\[|\\]$/,\n                    \"case-sensitivity\": {\n                        pattern: /(\\s)[si]$/i,\n                        lookbehind: true,\n                        alias: \"keyword\"\n                    },\n                    \"namespace\": {\n                        pattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n                        lookbehind: true,\n                        inside: {\n                            \"punctuation\": /\\|$/\n                        }\n                    },\n                    \"attr-name\": {\n                        pattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n                        lookbehind: true\n                    },\n                    \"attr-value\": [\n                        string,\n                        {\n                            pattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n                            lookbehind: true\n                        }\n                    ],\n                    \"operator\": /[|~*^$]?=/\n                }\n            },\n            \"n-th\": [\n                {\n                    pattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n                    lookbehind: true,\n                    inside: {\n                        \"number\": /[\\dn]+/,\n                        \"operator\": /[+-]/\n                    }\n                },\n                {\n                    pattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n                    lookbehind: true\n                }\n            ],\n            \"combinator\": />|\\+|~|\\|\\|/,\n            // the `tag` token has been existed and removed.\n            // because we can't find a perfect tokenize to match it.\n            // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.\n            \"punctuation\": /[(),]/\n        }\n    };\n    Prism.languages.css[\"atrule\"].inside[\"selector-function-argument\"].inside = selectorInside;\n    Prism.languages.insertBefore(\"css\", \"property\", {\n        \"variable\": {\n            pattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n            lookbehind: true\n        }\n    });\n    var unit = {\n        pattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n        lookbehind: true\n    };\n    // 123 -123 .123 -.123 12.3 -12.3\n    var number = {\n        pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n        lookbehind: true\n    };\n    Prism.languages.insertBefore(\"css\", \"function\", {\n        \"operator\": {\n            pattern: /(\\s)[+\\-*\\/](?=\\s)/,\n            lookbehind: true\n        },\n        // CAREFUL!\n        // Previewers and Inline color use hexcode and color.\n        \"hexcode\": {\n            pattern: /\\B#[\\da-f]{3,8}\\b/i,\n            alias: \"color\"\n        },\n        \"color\": [\n            {\n                pattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n                lookbehind: true\n            },\n            {\n                pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n                inside: {\n                    \"unit\": unit,\n                    \"number\": number,\n                    \"function\": /[\\w-]+(?=\\()/,\n                    \"punctuation\": /[(),]/\n                }\n            }\n        ],\n        // it's important that there is no boundary assertion after the hex digits\n        \"entity\": /\\\\[\\da-f]{1,8}/i,\n        \"unit\": unit,\n        \"number\": number\n    });\n})(Prism);\nPrism.languages.git = {\n    /*\n\t * A simple one line comment like in a git status command\n\t * For instance:\n\t * $ git status\n\t * # On branch infinite-scroll\n\t * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n\t * # and have 1 and 2 different commits each, respectively.\n\t * nothing to commit (working directory clean)\n\t */ \"comment\": /^#.*/m,\n    /*\n\t * Regexp to match the changed lines in a git diff output. Check the example below.\n\t */ \"deleted\": /^[-–].*/m,\n    \"inserted\": /^\\+.*/m,\n    /*\n\t * a string (double and simple quote)\n\t */ \"string\": /(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    /*\n\t * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n\t * For instance:\n\t * $ git add file.txt\n\t */ \"command\": {\n        pattern: /^.*\\$ git .*$/m,\n        inside: {\n            /*\n\t\t\t * A git command can contain a parameter starting by a single or a double dash followed by a string\n\t\t\t * For instance:\n\t\t\t * $ git diff --cached\n\t\t\t * $ git log -p\n\t\t\t */ \"parameter\": /\\s--?\\w+/\n        }\n    },\n    /*\n\t * Coordinates displayed in a git diff command\n\t * For instance:\n\t * $ git diff\n\t * diff --git file.txt file.txt\n\t * index 6214953..1d54a52 100644\n\t * --- file.txt\n\t * +++ file.txt\n\t * @@ -1 +1,2 @@\n\t * -Here's my tetx file\n\t * +Here's my text file\n\t * +And this is the second line\n\t */ \"coord\": /^@@.*@@$/m,\n    /*\n\t * Match a \"commit [SHA1]\" line in a git log output.\n\t * For instance:\n\t * $ git log\n\t * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n\t * Author: lgiraudel\n\t * Date:   Mon Feb 17 11:18:34 2014 +0100\n\t *\n\t *     Add of a new line\n\t */ \"commit-sha1\": /^commit \\w{40}$/m\n};\n(function(Prism) {\n    var specialEscape = {\n        pattern: /\\\\[\\\\(){}[\\]^$+*?|.]/,\n        alias: \"escape\"\n    };\n    var escape = /\\\\(?:x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u\\{[\\da-fA-F]+\\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;\n    var charSet = {\n        pattern: /\\.|\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n        alias: \"class-name\"\n    };\n    var charSetWithoutDot = {\n        pattern: /\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n        alias: \"class-name\"\n    };\n    var rangeChar = \"(?:[^\\\\\\\\-]|\" + escape.source + \")\";\n    var range = RegExp(rangeChar + \"-\" + rangeChar);\n    // the name of a capturing group\n    var groupName = {\n        pattern: /(<|')[^<>']+(?=[>']$)/,\n        lookbehind: true,\n        alias: \"variable\"\n    };\n    Prism.languages.regex = {\n        \"char-class\": {\n            pattern: /((?:^|[^\\\\])(?:\\\\\\\\)*)\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/,\n            lookbehind: true,\n            inside: {\n                \"char-class-negation\": {\n                    pattern: /(^\\[)\\^/,\n                    lookbehind: true,\n                    alias: \"operator\"\n                },\n                \"char-class-punctuation\": {\n                    pattern: /^\\[|\\]$/,\n                    alias: \"punctuation\"\n                },\n                \"range\": {\n                    pattern: range,\n                    inside: {\n                        \"escape\": escape,\n                        \"range-punctuation\": {\n                            pattern: /-/,\n                            alias: \"operator\"\n                        }\n                    }\n                },\n                \"special-escape\": specialEscape,\n                \"char-set\": charSetWithoutDot,\n                \"escape\": escape\n            }\n        },\n        \"special-escape\": specialEscape,\n        \"char-set\": charSet,\n        \"backreference\": [\n            {\n                // a backreference which is not an octal escape\n                pattern: /\\\\(?![123][0-7]{2})[1-9]/,\n                alias: \"keyword\"\n            },\n            {\n                pattern: /\\\\k<[^<>']+>/,\n                alias: \"keyword\",\n                inside: {\n                    \"group-name\": groupName\n                }\n            }\n        ],\n        \"anchor\": {\n            pattern: /[$^]|\\\\[ABbGZz]/,\n            alias: \"function\"\n        },\n        \"escape\": escape,\n        \"group\": [\n            {\n                // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html\n                // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs\n                // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)\n                pattern: /\\((?:\\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,\n                alias: \"punctuation\",\n                inside: {\n                    \"group-name\": groupName\n                }\n            },\n            {\n                pattern: /\\)/,\n                alias: \"punctuation\"\n            }\n        ],\n        \"quantifier\": {\n            pattern: /(?:[+*?]|\\{\\d+(?:,\\d*)?\\})[?+]?/,\n            alias: \"number\"\n        },\n        \"alternation\": {\n            pattern: /\\|/,\n            alias: \"keyword\"\n        }\n    };\n})(Prism);\nPrism.languages.scss = Prism.languages.extend(\"css\", {\n    \"comment\": {\n        pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n        lookbehind: true\n    },\n    \"atrule\": {\n        pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n        inside: {\n            \"rule\": /@[\\w-]+/\n        }\n    },\n    // url, compassified\n    \"url\": /(?:[-a-z]+-)?url(?=\\()/i,\n    // CSS selector regex is not appropriate for Sass\n    // since there can be lot more things (var, @ directive, nesting..)\n    // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n    // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n    // can \"pass\" as a selector- e.g: proper#{$erty})\n    // this one was hard to do, so please be careful if you edit this one :)\n    \"selector\": {\n        // Initial look-ahead is used to prevent matching of blank selectors\n        pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n        inside: {\n            \"parent\": {\n                pattern: /&/,\n                alias: \"important\"\n            },\n            \"placeholder\": /%[-\\w]+/,\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    },\n    \"property\": {\n        pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n        inside: {\n            \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n        }\n    }\n});\nPrism.languages.insertBefore(\"scss\", \"atrule\", {\n    \"keyword\": [\n        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\n        {\n            pattern: /( )(?:from|through)(?= )/,\n            lookbehind: true\n        }\n    ]\n});\nPrism.languages.insertBefore(\"scss\", \"important\", {\n    // var and interpolated vars\n    \"variable\": /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nPrism.languages.insertBefore(\"scss\", \"function\", {\n    \"module-modifier\": {\n        pattern: /\\b(?:as|hide|show|with)\\b/i,\n        alias: \"keyword\"\n    },\n    \"placeholder\": {\n        pattern: /%[-\\w]+/,\n        alias: \"selector\"\n    },\n    \"statement\": {\n        pattern: /\\B!(?:default|optional)\\b/i,\n        alias: \"keyword\"\n    },\n    \"boolean\": /\\b(?:false|true)\\b/,\n    \"null\": {\n        pattern: /\\bnull\\b/,\n        alias: \"keyword\"\n    },\n    \"operator\": {\n        pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n        lookbehind: true\n    }\n});\nPrism.languages.scss[\"atrule\"].inside.rest = Prism.languages.scss;\n(function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\") return;\n    /**\n\t * Plugin name which is used as a class name for <pre> which is activating the plugin\n\t *\n\t * @type {string}\n\t */ var PLUGIN_NAME = \"line-numbers\";\n    /**\n\t * Regular expression used for determining line breaks\n\t *\n\t * @type {RegExp}\n\t */ var NEW_LINE_EXP = /\\n(?!$)/g;\n    /**\n\t * Global exports\n\t */ var config = Prism.plugins.lineNumbers = {\n        /**\n\t\t * Get node for provided line number\n\t\t *\n\t\t * @param {Element} element pre element\n\t\t * @param {number} number line number\n\t\t * @returns {Element|undefined}\n\t\t */ getLine: function getLine(element, number) {\n            if (element.tagName !== \"PRE\" || !element.classList.contains(PLUGIN_NAME)) return;\n            var lineNumberRows = element.querySelector(\".line-numbers-rows\");\n            if (!lineNumberRows) return;\n            var lineNumberStart = parseInt(element.getAttribute(\"data-start\"), 10) || 1;\n            var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);\n            if (number < lineNumberStart) number = lineNumberStart;\n            if (number > lineNumberEnd) number = lineNumberEnd;\n            var lineIndex = number - lineNumberStart;\n            return lineNumberRows.children[lineIndex];\n        },\n        /**\n\t\t * Resizes the line numbers of the given element.\n\t\t *\n\t\t * This function will not add line numbers. It will only resize existing ones.\n\t\t *\n\t\t * @param {HTMLElement} element A `<pre>` element with line numbers.\n\t\t * @returns {void}\n\t\t */ resize: function resize(element) {\n            resizeElements([\n                element\n            ]);\n        },\n        /**\n\t\t * Whether the plugin can assume that the units font sizes and margins are not depended on the size of\n\t\t * the current viewport.\n\t\t *\n\t\t * Setting this to `true` will allow the plugin to do certain optimizations for better performance.\n\t\t *\n\t\t * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.\n\t\t *\n\t\t * @type {boolean}\n\t\t */ assumeViewportIndependence: true\n    };\n    /**\n\t * Resizes the given elements.\n\t *\n\t * @param {HTMLElement[]} elements\n\t */ function resizeElements(elements) {\n        elements = elements.filter(function(e) {\n            var codeStyles = getStyles(e);\n            var whiteSpace = codeStyles[\"white-space\"];\n            return whiteSpace === \"pre-wrap\" || whiteSpace === \"pre-line\";\n        });\n        if (elements.length == 0) return;\n        var infos = elements.map(function(element) {\n            var codeElement = element.querySelector(\"code\");\n            var lineNumbersWrapper = element.querySelector(\".line-numbers-rows\");\n            if (!codeElement || !lineNumbersWrapper) return undefined;\n            /** @type {HTMLElement} */ var lineNumberSizer = element.querySelector(\".line-numbers-sizer\");\n            var codeLines = codeElement.textContent.split(NEW_LINE_EXP);\n            if (!lineNumberSizer) {\n                lineNumberSizer = document.createElement(\"span\");\n                lineNumberSizer.className = \"line-numbers-sizer\";\n                codeElement.appendChild(lineNumberSizer);\n            }\n            lineNumberSizer.innerHTML = \"0\";\n            lineNumberSizer.style.display = \"block\";\n            var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;\n            lineNumberSizer.innerHTML = \"\";\n            return {\n                element: element,\n                lines: codeLines,\n                lineHeights: [],\n                oneLinerHeight: oneLinerHeight,\n                sizer: lineNumberSizer\n            };\n        }).filter(Boolean);\n        infos.forEach(function(info) {\n            var lineNumberSizer = info.sizer;\n            var lines = info.lines;\n            var lineHeights = info.lineHeights;\n            var oneLinerHeight = info.oneLinerHeight;\n            lineHeights[lines.length - 1] = undefined;\n            lines.forEach(function(line, index) {\n                if (line && line.length > 1) {\n                    var e = lineNumberSizer.appendChild(document.createElement(\"span\"));\n                    e.style.display = \"block\";\n                    e.textContent = line;\n                } else lineHeights[index] = oneLinerHeight;\n            });\n        });\n        infos.forEach(function(info) {\n            var lineNumberSizer = info.sizer;\n            var lineHeights = info.lineHeights;\n            var childIndex = 0;\n            for(var i = 0; i < lineHeights.length; i++)if (lineHeights[i] === undefined) lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;\n        });\n        infos.forEach(function(info) {\n            var lineNumberSizer = info.sizer;\n            var wrapper = info.element.querySelector(\".line-numbers-rows\");\n            lineNumberSizer.style.display = \"none\";\n            lineNumberSizer.innerHTML = \"\";\n            info.lineHeights.forEach(function(height, lineNumber) {\n                wrapper.children[lineNumber].style.height = height + \"px\";\n            });\n        });\n    }\n    /**\n\t * Returns style declarations for the element\n\t *\n\t * @param {Element} element\n\t */ function getStyles(element) {\n        if (!element) return null;\n        return window.getComputedStyle ? getComputedStyle(element) : element.currentStyle || null;\n    }\n    var lastWidth = undefined;\n    window.addEventListener(\"resize\", function() {\n        if (config.assumeViewportIndependence && lastWidth === window.innerWidth) return;\n        lastWidth = window.innerWidth;\n        resizeElements(Array.prototype.slice.call(document.querySelectorAll(\"pre.\" + PLUGIN_NAME)));\n    });\n    Prism.hooks.add(\"complete\", function(env) {\n        if (!env.code) return;\n        var code = /** @type {Element} */ env.element;\n        var pre = /** @type {HTMLElement} */ code.parentNode;\n        // works only for <code> wrapped inside <pre> (not inline)\n        if (!pre || !/pre/i.test(pre.nodeName)) return;\n        // Abort if line numbers already exists\n        if (code.querySelector(\".line-numbers-rows\")) return;\n        // only add line numbers if <code> or one of its ancestors has the `line-numbers` class\n        if (!Prism.util.isActive(code, PLUGIN_NAME)) return;\n        // Remove the class 'line-numbers' from the <code>\n        code.classList.remove(PLUGIN_NAME);\n        // Add the class 'line-numbers' to the <pre>\n        pre.classList.add(PLUGIN_NAME);\n        var match = env.code.match(NEW_LINE_EXP);\n        var linesNum = match ? match.length + 1 : 1;\n        var lineNumbersWrapper;\n        var lines = new Array(linesNum + 1).join(\"<span></span>\");\n        lineNumbersWrapper = document.createElement(\"span\");\n        lineNumbersWrapper.setAttribute(\"aria-hidden\", \"true\");\n        lineNumbersWrapper.className = \"line-numbers-rows\";\n        lineNumbersWrapper.innerHTML = lines;\n        if (pre.hasAttribute(\"data-start\")) pre.style.counterReset = \"linenumber \" + (parseInt(pre.getAttribute(\"data-start\"), 10) - 1);\n        env.element.appendChild(lineNumbersWrapper);\n        resizeElements([\n            pre\n        ]);\n        Prism.hooks.run(\"line-numbers\", env);\n    });\n    Prism.hooks.add(\"line-numbers\", function(env) {\n        env.plugins = env.plugins || {};\n        env.plugins.lineNumbers = true;\n    });\n})();\n(function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\" || !Function.prototype.bind) return;\n    var previewers = {\n        // gradient must be defined before color and angle\n        \"gradient\": {\n            create: function() {\n                // Stores already processed gradients so that we don't\n                // make the conversion every time the previewer is shown\n                var cache = {};\n                /**\n\t\t\t\t * Returns a W3C-valid linear gradient\n\t\t\t\t *\n\t\t\t\t * @param {string} prefix Vendor prefix if any (\"-moz-\", \"-webkit-\", etc.)\n\t\t\t\t * @param {string} func Gradient function name (\"linear-gradient\")\n\t\t\t\t * @param {string[]} values Array of the gradient function parameters ([\"0deg\", \"red 0%\", \"blue 100%\"])\n\t\t\t\t */ var convertToW3CLinearGradient = function convertToW3CLinearGradient(prefix, func, values) {\n                    // Default value for angle\n                    var angle = \"180deg\";\n                    if (/^(?:-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:deg|rad)|to\\b|top|right|bottom|left)/.test(values[0])) {\n                        angle = values.shift();\n                        if (angle.indexOf(\"to \") < 0) {\n                            // Angle uses old keywords\n                            // W3C syntax uses \"to\" + opposite keywords\n                            if (angle.indexOf(\"top\") >= 0) {\n                                if (angle.indexOf(\"left\") >= 0) angle = \"to bottom right\";\n                                else if (angle.indexOf(\"right\") >= 0) angle = \"to bottom left\";\n                                else angle = \"to bottom\";\n                            } else if (angle.indexOf(\"bottom\") >= 0) {\n                                if (angle.indexOf(\"left\") >= 0) angle = \"to top right\";\n                                else if (angle.indexOf(\"right\") >= 0) angle = \"to top left\";\n                                else angle = \"to top\";\n                            } else if (angle.indexOf(\"left\") >= 0) angle = \"to right\";\n                            else if (angle.indexOf(\"right\") >= 0) angle = \"to left\";\n                            else if (prefix) {\n                                // Angle is shifted by 90deg in prefixed gradients\n                                if (angle.indexOf(\"deg\") >= 0) angle = 90 - parseFloat(angle) + \"deg\";\n                                else if (angle.indexOf(\"rad\") >= 0) angle = Math.PI / 2 - parseFloat(angle) + \"rad\";\n                            }\n                        }\n                    }\n                    return func + \"(\" + angle + \",\" + values.join(\",\") + \")\";\n                };\n                /**\n\t\t\t\t * Returns a W3C-valid radial gradient\n\t\t\t\t *\n\t\t\t\t * @param {string} prefix Vendor prefix if any (\"-moz-\", \"-webkit-\", etc.)\n\t\t\t\t * @param {string} func Gradient function name (\"linear-gradient\")\n\t\t\t\t * @param {string[]} values Array of the gradient function parameters ([\"0deg\", \"red 0%\", \"blue 100%\"])\n\t\t\t\t */ var convertToW3CRadialGradient = function convertToW3CRadialGradient(prefix, func, values) {\n                    if (values[0].indexOf(\"at\") < 0) {\n                        // Looks like old syntax\n                        // Default values\n                        var position = \"center\";\n                        var shape = \"ellipse\";\n                        var size = \"farthest-corner\";\n                        if (/\\b(?:bottom|center|left|right|top)\\b|^\\d+/.test(values[0])) // Found a position\n                        // Remove angle value, if any\n                        position = values.shift().replace(/\\s*-?\\d+(?:deg|rad)\\s*/, \"\");\n                        if (/\\b(?:circle|closest|contain|cover|ellipse|farthest)\\b/.test(values[0])) {\n                            // Found a shape and/or size\n                            var shapeSizeParts = values.shift().split(/\\s+/);\n                            if (shapeSizeParts[0] && (shapeSizeParts[0] === \"circle\" || shapeSizeParts[0] === \"ellipse\")) shape = shapeSizeParts.shift();\n                            if (shapeSizeParts[0]) size = shapeSizeParts.shift();\n                            // Old keywords are converted to their synonyms\n                            if (size === \"cover\") size = \"farthest-corner\";\n                            else if (size === \"contain\") size = \"clothest-side\";\n                        }\n                        return func + \"(\" + shape + \" \" + size + \" at \" + position + \",\" + values.join(\",\") + \")\";\n                    }\n                    return func + \"(\" + values.join(\",\") + \")\";\n                };\n                /**\n\t\t\t\t * Converts a gradient to a W3C-valid one\n\t\t\t\t * Does not support old webkit syntax (-webkit-gradient(linear...) and -webkit-gradient(radial...))\n\t\t\t\t *\n\t\t\t\t * @param {string} gradient The CSS gradient\n\t\t\t\t */ var convertToW3CGradient = function convertToW3CGradient(gradient) {\n                    if (cache[gradient]) return cache[gradient];\n                    var parts = gradient.match(/^(\\b|\\B-[a-z]{1,10}-)((?:repeating-)?(?:linear|radial)-gradient)/);\n                    // \"\", \"-moz-\", etc.\n                    var prefix = parts && parts[1];\n                    // \"linear-gradient\", \"radial-gradient\", etc.\n                    var func = parts && parts[2];\n                    var values = gradient.replace(/^(?:\\b|\\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\\(|\\)$/g, \"\").split(/\\s*,\\s*/);\n                    if (func.indexOf(\"linear\") >= 0) return cache[gradient] = convertToW3CLinearGradient(prefix, func, values);\n                    else if (func.indexOf(\"radial\") >= 0) return cache[gradient] = convertToW3CRadialGradient(prefix, func, values);\n                    return cache[gradient] = func + \"(\" + values.join(\",\") + \")\";\n                };\n                return function() {\n                    new Prism.plugins.Previewer(\"gradient\", function(value) {\n                        this.firstChild.style.backgroundImage = \"\";\n                        this.firstChild.style.backgroundImage = convertToW3CGradient(value);\n                        return !!this.firstChild.style.backgroundImage;\n                    }, \"*\", function() {\n                        this._elt.innerHTML = \"<div></div>\";\n                    });\n                };\n            }(),\n            tokens: {\n                \"gradient\": {\n                    pattern: /(?:\\b|\\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\\((?:(?:hsl|rgb)a?\\(.+?\\)|[^\\)])+\\)/gi,\n                    inside: {\n                        \"function\": /[\\w-]+(?=\\()/,\n                        \"punctuation\": /[(),]/\n                    }\n                }\n            },\n            languages: {\n                \"css\": true,\n                \"less\": true,\n                \"sass\": [\n                    {\n                        lang: \"sass\",\n                        before: \"punctuation\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"variable-line\"]\n                    },\n                    {\n                        lang: \"sass\",\n                        before: \"punctuation\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"property-line\"]\n                    }\n                ],\n                \"scss\": true,\n                \"stylus\": [\n                    {\n                        lang: \"stylus\",\n                        before: \"func\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"property-declaration\"].inside\n                    },\n                    {\n                        lang: \"stylus\",\n                        before: \"func\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"variable-declaration\"].inside\n                    }\n                ]\n            }\n        },\n        \"angle\": {\n            create: function create() {\n                new Prism.plugins.Previewer(\"angle\", function(value) {\n                    var num = parseFloat(value);\n                    var unit = value.match(/[a-z]+$/i);\n                    var max;\n                    var percentage;\n                    if (!num || !unit) return false;\n                    unit = unit[0];\n                    switch(unit){\n                        case \"deg\":\n                            max = 360;\n                            break;\n                        case \"grad\":\n                            max = 400;\n                            break;\n                        case \"rad\":\n                            max = 2 * Math.PI;\n                            break;\n                        case \"turn\":\n                            max = 1;\n                    }\n                    percentage = 100 * num / max;\n                    percentage %= 100;\n                    this[(num < 0 ? \"set\" : \"remove\") + \"Attribute\"](\"data-negative\", \"\");\n                    this.querySelector(\"circle\").style.strokeDasharray = Math.abs(percentage) + \",500\";\n                    return true;\n                }, \"*\", function() {\n                    this._elt.innerHTML = '<svg viewBox=\"0 0 64 64\"><circle r=\"16\" cy=\"32\" cx=\"32\"></circle></svg>';\n                });\n            },\n            tokens: {\n                \"angle\": /(?:\\b|\\B-|(?=\\B\\.))(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:deg|g?rad|turn)\\b/i\n            },\n            languages: {\n                \"css\": true,\n                \"less\": true,\n                \"markup\": {\n                    lang: \"markup\",\n                    before: \"punctuation\",\n                    inside: \"inside\",\n                    root: Prism.languages.markup && Prism.languages.markup[\"tag\"].inside[\"attr-value\"]\n                },\n                \"sass\": [\n                    {\n                        lang: \"sass\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"property-line\"]\n                    },\n                    {\n                        lang: \"sass\",\n                        before: \"operator\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"variable-line\"]\n                    }\n                ],\n                \"scss\": true,\n                \"stylus\": [\n                    {\n                        lang: \"stylus\",\n                        before: \"func\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"property-declaration\"].inside\n                    },\n                    {\n                        lang: \"stylus\",\n                        before: \"func\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"variable-declaration\"].inside\n                    }\n                ]\n            }\n        },\n        \"color\": {\n            create: function create() {\n                new Prism.plugins.Previewer(\"color\", function(value) {\n                    this.style.backgroundColor = \"\";\n                    this.style.backgroundColor = value;\n                    return !!this.style.backgroundColor;\n                });\n            },\n            tokens: {\n                \"color\": [\n                    Prism.languages.css[\"hexcode\"]\n                ].concat(Prism.languages.css[\"color\"])\n            },\n            languages: {\n                // CSS extras is required, so css and scss are not necessary\n                \"css\": false,\n                \"less\": true,\n                \"markup\": {\n                    lang: \"markup\",\n                    before: \"punctuation\",\n                    inside: \"inside\",\n                    root: Prism.languages.markup && Prism.languages.markup[\"tag\"].inside[\"attr-value\"]\n                },\n                \"sass\": [\n                    {\n                        lang: \"sass\",\n                        before: \"punctuation\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"variable-line\"]\n                    },\n                    {\n                        lang: \"sass\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"property-line\"]\n                    }\n                ],\n                \"scss\": false,\n                \"stylus\": [\n                    {\n                        lang: \"stylus\",\n                        before: \"hexcode\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"property-declaration\"].inside\n                    },\n                    {\n                        lang: \"stylus\",\n                        before: \"hexcode\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"variable-declaration\"].inside\n                    }\n                ]\n            }\n        },\n        \"easing\": {\n            create: function create() {\n                new Prism.plugins.Previewer(\"easing\", function(value) {\n                    value = ({\n                        \"linear\": \"0,0,1,1\",\n                        \"ease\": \".25,.1,.25,1\",\n                        \"ease-in\": \".42,0,1,1\",\n                        \"ease-out\": \"0,0,.58,1\",\n                        \"ease-in-out\": \".42,0,.58,1\"\n                    })[value] || value;\n                    var p = value.match(/-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/g);\n                    if (p.length === 4) {\n                        p = p.map(function(p, i) {\n                            return (i % 2 ? 1 - p : p) * 100;\n                        });\n                        this.querySelector(\"path\").setAttribute(\"d\", \"M0,100 C\" + p[0] + \",\" + p[1] + \", \" + p[2] + \",\" + p[3] + \", 100,0\");\n                        var lines = this.querySelectorAll(\"line\");\n                        lines[0].setAttribute(\"x2\", p[0]);\n                        lines[0].setAttribute(\"y2\", p[1]);\n                        lines[1].setAttribute(\"x2\", p[2]);\n                        lines[1].setAttribute(\"y2\", p[3]);\n                        return true;\n                    }\n                    return false;\n                }, \"*\", function() {\n                    this._elt.innerHTML = '<svg viewBox=\"-20 -20 140 140\" width=\"100\" height=\"100\"><defs><marker id=\"prism-previewer-easing-marker\" viewBox=\"0 0 4 4\" refX=\"2\" refY=\"2\" markerUnits=\"strokeWidth\"><circle cx=\"2\" cy=\"2\" r=\"1.5\" /></marker></defs><path d=\"M0,100 C20,50, 40,30, 100,0\" /><line x1=\"0\" y1=\"100\" x2=\"20\" y2=\"50\" marker-start=\"url(#prism-previewer-easing-marker)\" marker-end=\"url(#prism-previewer-easing-marker)\" /><line x1=\"100\" y1=\"0\" x2=\"40\" y2=\"30\" marker-start=\"url(#prism-previewer-easing-marker)\" marker-end=\"url(#prism-previewer-easing-marker)\" /></svg>';\n                });\n            },\n            tokens: {\n                \"easing\": {\n                    pattern: /\\bcubic-bezier\\((?:-?(?:\\d+(?:\\.\\d+)?|\\.\\d+),\\s*){3}-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)\\)\\B|\\b(?:ease(?:-in)?(?:-out)?|linear)(?=\\s|[;}]|$)/i,\n                    inside: {\n                        \"function\": /[\\w-]+(?=\\()/,\n                        \"punctuation\": /[(),]/\n                    }\n                }\n            },\n            languages: {\n                \"css\": true,\n                \"less\": true,\n                \"sass\": [\n                    {\n                        lang: \"sass\",\n                        inside: \"inside\",\n                        before: \"punctuation\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"variable-line\"]\n                    },\n                    {\n                        lang: \"sass\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"property-line\"]\n                    }\n                ],\n                \"scss\": true,\n                \"stylus\": [\n                    {\n                        lang: \"stylus\",\n                        before: \"hexcode\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"property-declaration\"].inside\n                    },\n                    {\n                        lang: \"stylus\",\n                        before: \"hexcode\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"variable-declaration\"].inside\n                    }\n                ]\n            }\n        },\n        \"time\": {\n            create: function create() {\n                new Prism.plugins.Previewer(\"time\", function(value) {\n                    var num = parseFloat(value);\n                    var unit = value.match(/[a-z]+$/i);\n                    if (!num || !unit) return false;\n                    unit = unit[0];\n                    this.querySelector(\"circle\").style.animationDuration = 2 * num + unit;\n                    return true;\n                }, \"*\", function() {\n                    this._elt.innerHTML = '<svg viewBox=\"0 0 64 64\"><circle r=\"16\" cy=\"32\" cx=\"32\"></circle></svg>';\n                });\n            },\n            tokens: {\n                \"time\": /(?:\\b|\\B-|(?=\\B\\.))(?:\\d+(?:\\.\\d+)?|\\.\\d+)m?s\\b/i\n            },\n            languages: {\n                \"css\": true,\n                \"less\": true,\n                \"markup\": {\n                    lang: \"markup\",\n                    before: \"punctuation\",\n                    inside: \"inside\",\n                    root: Prism.languages.markup && Prism.languages.markup[\"tag\"].inside[\"attr-value\"]\n                },\n                \"sass\": [\n                    {\n                        lang: \"sass\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"property-line\"]\n                    },\n                    {\n                        lang: \"sass\",\n                        before: \"operator\",\n                        inside: \"inside\",\n                        root: Prism.languages.sass && Prism.languages.sass[\"variable-line\"]\n                    }\n                ],\n                \"scss\": true,\n                \"stylus\": [\n                    {\n                        lang: \"stylus\",\n                        before: \"hexcode\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"property-declaration\"].inside\n                    },\n                    {\n                        lang: \"stylus\",\n                        before: \"hexcode\",\n                        inside: \"rest\",\n                        root: Prism.languages.stylus && Prism.languages.stylus[\"variable-declaration\"].inside\n                    }\n                ]\n            }\n        }\n    };\n    /**\n\t * Returns the absolute X, Y offsets for an element\n\t *\n\t * @param {HTMLElement} element\n\t * @returns {{top: number, right: number, bottom: number, left: number, width: number, height: number}}\n\t */ var getOffset = function getOffset(element) {\n        var elementBounds = element.getBoundingClientRect();\n        var left = elementBounds.left;\n        var top = elementBounds.top;\n        var documentBounds = document.documentElement.getBoundingClientRect();\n        left -= documentBounds.left;\n        top -= documentBounds.top;\n        return {\n            top: top,\n            right: innerWidth - left - elementBounds.width,\n            bottom: innerHeight - top - elementBounds.height,\n            left: left,\n            width: elementBounds.width,\n            height: elementBounds.height\n        };\n    };\n    var TOKEN_CLASS = \"token\";\n    var ACTIVE_CLASS = \"active\";\n    var FLIPPED_CLASS = \"flipped\";\n    /**\n\t * Previewer constructor\n\t *\n\t * @param {string} type Unique previewer type\n\t * @param {Function} updater Function that will be called on mouseover.\n\t * @param {string[]|string} [supportedLanguages] Aliases of the languages this previewer must be enabled for. Defaults to \"*\", all languages.\n\t * @param {Function} [initializer] Function that will be called on initialization.\n\t * @class\n\t */ var Previewer = function Previewer1(type, updater, supportedLanguages, initializer) {\n        this._elt = null;\n        this._type = type;\n        this._token = null;\n        this.updater = updater;\n        this._mouseout = this.mouseout.bind(this);\n        this.initializer = initializer;\n        var _$self = this;\n        if (!supportedLanguages) supportedLanguages = [\n            \"*\"\n        ];\n        if (!Array.isArray(supportedLanguages)) supportedLanguages = [\n            supportedLanguages\n        ];\n        supportedLanguages.forEach(function(lang) {\n            if (typeof lang !== \"string\") lang = lang.lang;\n            if (!Previewer.byLanguages[lang]) Previewer.byLanguages[lang] = [];\n            if (Previewer.byLanguages[lang].indexOf(_$self) < 0) Previewer.byLanguages[lang].push(_$self);\n        });\n        Previewer.byType[type] = this;\n    };\n    /**\n\t * Creates the HTML element for the previewer.\n\t */ Previewer.prototype.init = function() {\n        if (this._elt) return;\n        this._elt = document.createElement(\"div\");\n        this._elt.className = \"prism-previewer prism-previewer-\" + this._type;\n        document.body.appendChild(this._elt);\n        if (this.initializer) this.initializer();\n    };\n    /**\n\t * @param {Element} token\n\t * @returns {boolean}\n\t */ Previewer.prototype.isDisabled = function(token) {\n        do if (token.hasAttribute && token.hasAttribute(\"data-previewers\")) {\n            var previewers = token.getAttribute(\"data-previewers\");\n            return (previewers || \"\").split(/\\s+/).indexOf(this._type) === -1;\n        }\n        while (token = token.parentNode);\n        return false;\n    };\n    /**\n\t * Checks the class name of each hovered element\n\t *\n\t * @param {Element} token\n\t */ Previewer.prototype.check = function(token) {\n        if (token.classList.contains(TOKEN_CLASS) && this.isDisabled(token)) return;\n        do {\n            if (token.classList && token.classList.contains(TOKEN_CLASS) && token.classList.contains(this._type)) break;\n        }while (token = token.parentNode);\n        if (token && token !== this._token) {\n            this._token = token;\n            this.show();\n        }\n    };\n    /**\n\t * Called on mouseout\n\t */ Previewer.prototype.mouseout = function() {\n        this._token.removeEventListener(\"mouseout\", this._mouseout, false);\n        this._token = null;\n        this.hide();\n    };\n    /**\n\t * Shows the previewer positioned properly for the current token.\n\t */ Previewer.prototype.show = function() {\n        if (!this._elt) this.init();\n        if (!this._token) return;\n        if (this.updater.call(this._elt, this._token.textContent)) {\n            this._token.addEventListener(\"mouseout\", this._mouseout, false);\n            var offset = getOffset(this._token);\n            this._elt.classList.add(ACTIVE_CLASS);\n            if (offset.top - this._elt.offsetHeight > 0) {\n                this._elt.classList.remove(FLIPPED_CLASS);\n                this._elt.style.top = offset.top + \"px\";\n                this._elt.style.bottom = \"\";\n            } else {\n                this._elt.classList.add(FLIPPED_CLASS);\n                this._elt.style.bottom = offset.bottom + \"px\";\n                this._elt.style.top = \"\";\n            }\n            this._elt.style.left = offset.left + Math.min(200, offset.width / 2) + \"px\";\n        } else this.hide();\n    };\n    /**\n\t * Hides the previewer.\n\t */ Previewer.prototype.hide = function() {\n        this._elt.classList.remove(ACTIVE_CLASS);\n    };\n    /**\n\t * Map of all registered previewers by language\n\t *\n\t * @type {{}}\n\t */ Previewer.byLanguages = {};\n    /**\n\t * Map of all registered previewers by type\n\t *\n\t * @type {{}}\n\t */ Previewer.byType = {};\n    /**\n\t * Initializes the mouseover event on the code block.\n\t *\n\t * @param {HTMLElement} elt The code block (env.element)\n\t * @param {string} lang The language (env.language)\n\t */ Previewer.initEvents = function(elt, lang) {\n        var previewers = [];\n        if (Previewer.byLanguages[lang]) previewers = previewers.concat(Previewer.byLanguages[lang]);\n        if (Previewer.byLanguages[\"*\"]) previewers = previewers.concat(Previewer.byLanguages[\"*\"]);\n        elt.addEventListener(\"mouseover\", function(e) {\n            var target = e.target;\n            previewers.forEach(function(previewer) {\n                previewer.check(target);\n            });\n        }, false);\n    };\n    Prism.plugins.Previewer = Previewer;\n    Prism.hooks.add(\"before-highlight\", function(env) {\n        for(var previewer in previewers){\n            var languages = previewers[previewer].languages;\n            if (env.language && languages[env.language] && !languages[env.language].initialized) {\n                var lang = languages[env.language];\n                if (!Array.isArray(lang)) lang = [\n                    lang\n                ];\n                lang.forEach(function(lang) {\n                    var before;\n                    var inside;\n                    var root;\n                    var skip;\n                    if (lang === true) {\n                        before = \"important\";\n                        inside = env.language;\n                        lang = env.language;\n                    } else {\n                        before = lang.before || \"important\";\n                        inside = lang.inside || lang.lang;\n                        root = lang.root || Prism.languages;\n                        skip = lang.skip;\n                        lang = env.language;\n                    }\n                    if (!skip && Prism.languages[lang]) {\n                        Prism.languages.insertBefore(inside, before, previewers[previewer].tokens, root);\n                        env.grammar = Prism.languages[lang];\n                        languages[env.language] = {\n                            initialized: true\n                        };\n                    }\n                });\n            }\n        }\n    });\n    // Initialize the previewers only when needed\n    Prism.hooks.add(\"after-highlight\", function(env) {\n        if (Previewer.byLanguages[\"*\"] || Previewer.byLanguages[env.language]) Previewer.initEvents(env.element, env.language);\n    });\n    for(var previewer in previewers)previewers[previewer].create();\n})();\n(function() {\n    if (typeof Prism === \"undefined\") return;\n    var assign = Object.assign || function(obj1, obj2) {\n        for(var name in obj2)if (obj2.hasOwnProperty(name)) obj1[name] = obj2[name];\n        return obj1;\n    };\n    function NormalizeWhitespace(defaults) {\n        this.defaults = assign({}, defaults);\n    }\n    function toCamelCase(value) {\n        return value.replace(/-(\\w)/g, function(match, firstChar) {\n            return firstChar.toUpperCase();\n        });\n    }\n    function tabLen(str) {\n        var res = 0;\n        for(var i = 0; i < str.length; ++i)if (str.charCodeAt(i) == \"\t\".charCodeAt(0)) res += 3;\n        return str.length + res;\n    }\n    var settingsConfig = {\n        \"remove-trailing\": \"boolean\",\n        \"remove-indent\": \"boolean\",\n        \"left-trim\": \"boolean\",\n        \"right-trim\": \"boolean\",\n        \"break-lines\": \"number\",\n        \"indent\": \"number\",\n        \"remove-initial-line-feed\": \"boolean\",\n        \"tabs-to-spaces\": \"number\",\n        \"spaces-to-tabs\": \"number\"\n    };\n    NormalizeWhitespace.prototype = {\n        setDefaults: function setDefaults(defaults) {\n            this.defaults = assign(this.defaults, defaults);\n        },\n        normalize: function normalize(input, settings) {\n            settings = assign(this.defaults, settings);\n            for(var name in settings){\n                var methodName = toCamelCase(name);\n                if (name !== \"normalize\" && methodName !== \"setDefaults\" && settings[name] && this[methodName]) input = this[methodName].call(this, input, settings[name]);\n            }\n            return input;\n        },\n        /*\n\t\t * Normalization methods\n\t\t */ leftTrim: function leftTrim(input) {\n            return input.replace(/^\\s+/, \"\");\n        },\n        rightTrim: function rightTrim(input) {\n            return input.replace(/\\s+$/, \"\");\n        },\n        tabsToSpaces: function tabsToSpaces(input, spaces) {\n            spaces = spaces | 0 || 4;\n            return input.replace(/\\t/g, new Array(++spaces).join(\" \"));\n        },\n        spacesToTabs: function spacesToTabs(input, spaces) {\n            spaces = spaces | 0 || 4;\n            return input.replace(RegExp(\" {\" + spaces + \"}\", \"g\"), \"\t\");\n        },\n        removeTrailing: function removeTrailing(input) {\n            return input.replace(/\\s*?$/gm, \"\");\n        },\n        // Support for deprecated plugin remove-initial-line-feed\n        removeInitialLineFeed: function removeInitialLineFeed(input) {\n            return input.replace(/^(?:\\r?\\n|\\r)/, \"\");\n        },\n        removeIndent: function removeIndent(input) {\n            var indents = input.match(/^[^\\S\\n\\r]*(?=\\S)/gm);\n            if (!indents || !indents[0].length) return input;\n            indents.sort(function(a, b) {\n                return a.length - b.length;\n            });\n            if (!indents[0].length) return input;\n            return input.replace(RegExp(\"^\" + indents[0], \"gm\"), \"\");\n        },\n        indent: function indent(input, tabs) {\n            return input.replace(/^[^\\S\\n\\r]*(?=\\S)/gm, new Array(++tabs).join(\"\t\") + \"$&\");\n        },\n        breakLines: function breakLines(input, characters) {\n            characters = characters === true ? 80 : characters | 0 || 80;\n            var lines = input.split(\"\\n\");\n            for(var i = 0; i < lines.length; ++i){\n                if (tabLen(lines[i]) <= characters) continue;\n                var line = lines[i].split(/(\\s+)/g);\n                var len = 0;\n                for(var j = 0; j < line.length; ++j){\n                    var tl = tabLen(line[j]);\n                    len += tl;\n                    if (len > characters) {\n                        line[j] = \"\\n\" + line[j];\n                        len = tl;\n                    }\n                }\n                lines[i] = line.join(\"\");\n            }\n            return lines.join(\"\\n\");\n        }\n    };\n    // Support node modules\n    if (typeof module !== \"undefined\" && module.exports) module.exports = NormalizeWhitespace;\n    Prism.plugins.NormalizeWhitespace = new NormalizeWhitespace({\n        \"remove-trailing\": true,\n        \"remove-indent\": true,\n        \"left-trim\": true,\n        \"right-trim\": true,\n        indent: 4\n    });\n    Prism.hooks.add(\"before-sanity-check\", function(env) {\n        var Normalizer = Prism.plugins.NormalizeWhitespace;\n        // Check settings\n        if (env.settings && env.settings[\"whitespace-normalization\"] === false) return;\n        // Check classes\n        if (!Prism.util.isActive(env.element, \"whitespace-normalization\", true)) return;\n        // Simple mode if there is no env.element\n        if ((!env.element || !env.element.parentNode) && env.code) {\n            env.code = Normalizer.normalize(env.code, env.settings);\n            return;\n        }\n        // Normal mode\n        var pre = env.element.parentNode;\n        if (!env.code || !pre || pre.nodeName.toLowerCase() !== \"pre\") return;\n        if (env.settings == null) env.settings = {};\n        // Read settings from 'data-' attributes\n        for(var key in settingsConfig)if (Object.hasOwnProperty.call(settingsConfig, key)) {\n            var settingType = settingsConfig[key];\n            if (pre.hasAttribute(\"data-\" + key)) try {\n                var value = JSON.parse(pre.getAttribute(\"data-\" + key) || \"true\");\n                if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === settingType) env.settings[key] = value;\n            } catch (_error) {\n            // ignore error\n            }\n        }\n        var children = pre.childNodes;\n        var before = \"\";\n        var after = \"\";\n        var codeFound = false;\n        // Move surrounding whitespace from the <pre> tag into the <code> tag\n        for(var i = 0; i < children.length; ++i){\n            var node = children[i];\n            if (node == env.element) codeFound = true;\n            else if (node.nodeName === \"#text\") {\n                if (codeFound) after += node.nodeValue;\n                else before += node.nodeValue;\n                pre.removeChild(node);\n                --i;\n            }\n        }\n        if (!env.element.children.length || !Prism.plugins.KeepMarkup) {\n            env.code = before + env.code + after;\n            env.code = Normalizer.normalize(env.code, env.settings);\n        } else {\n            // Preserve markup for keep-markup plugin\n            var html = before + env.element.innerHTML + after;\n            env.element.innerHTML = Normalizer.normalize(html, env.settings);\n            env.code = env.element.textContent;\n        }\n    });\n})();\n(function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\") return;\n    var callbacks = [];\n    var map = {};\n    var noop = function noop() {};\n    Prism.plugins.toolbar = {};\n    /**\n\t * @typedef ButtonOptions\n\t * @property {string} text The text displayed.\n\t * @property {string} [url] The URL of the link which will be created.\n\t * @property {Function} [onClick] The event listener for the `click` event of the created button.\n\t * @property {string} [className] The class attribute to include with element.\n\t */ /**\n\t * Register a button callback with the toolbar.\n\t *\n\t * @param {string} key\n\t * @param {ButtonOptions|Function} opts\n\t */ var registerButton = Prism.plugins.toolbar.registerButton = function registerButton(key, opts) {\n        var callback;\n        if (typeof opts === \"function\") callback = opts;\n        else callback = function callback(env) {\n            var element;\n            if (typeof opts.onClick === \"function\") {\n                element = document.createElement(\"button\");\n                element.type = \"button\";\n                element.addEventListener(\"click\", function() {\n                    opts.onClick.call(this, env);\n                });\n            } else if (typeof opts.url === \"string\") {\n                element = document.createElement(\"a\");\n                element.href = opts.url;\n            } else element = document.createElement(\"span\");\n            if (opts.className) element.classList.add(opts.className);\n            element.textContent = opts.text;\n            return element;\n        };\n        if (key in map) {\n            console.warn('There is a button with the key \"' + key + '\" registered already.');\n            return;\n        }\n        callbacks.push(map[key] = callback);\n    };\n    /**\n\t * Returns the callback order of the given element.\n\t *\n\t * @param {HTMLElement} element\n\t * @returns {string[] | undefined}\n\t */ function getOrder(element) {\n        while(element){\n            var order = element.getAttribute(\"data-toolbar-order\");\n            if (order != null) {\n                order = order.trim();\n                if (order.length) return order.split(/\\s*,\\s*/g);\n                else return [];\n            }\n            element = element.parentElement;\n        }\n    }\n    /**\n\t * Post-highlight Prism hook callback.\n\t *\n\t * @param env\n\t */ var hook = Prism.plugins.toolbar.hook = function hook(env) {\n        // Check if inline or actual code block (credit to line-numbers plugin)\n        var pre = env.element.parentNode;\n        if (!pre || !/pre/i.test(pre.nodeName)) return;\n        // Autoloader rehighlights, so only do this once.\n        if (pre.parentNode.classList.contains(\"code-toolbar\")) return;\n        // Create wrapper for <pre> to prevent scrolling toolbar with content\n        var wrapper = document.createElement(\"div\");\n        wrapper.classList.add(\"code-toolbar\");\n        pre.parentNode.insertBefore(wrapper, pre);\n        wrapper.appendChild(pre);\n        // Setup the toolbar\n        var toolbar = document.createElement(\"div\");\n        toolbar.classList.add(\"toolbar\");\n        // order callbacks\n        var elementCallbacks = callbacks;\n        var order = getOrder(env.element);\n        if (order) elementCallbacks = order.map(function(key) {\n            return map[key] || noop;\n        });\n        elementCallbacks.forEach(function(callback) {\n            var element = callback(env);\n            if (!element) return;\n            var item = document.createElement(\"div\");\n            item.classList.add(\"toolbar-item\");\n            item.appendChild(element);\n            toolbar.appendChild(item);\n        });\n        // Add our toolbar to the currently created wrapper of <pre> tag\n        wrapper.appendChild(toolbar);\n    };\n    registerButton(\"label\", function(env) {\n        var pre = env.element.parentNode;\n        if (!pre || !/pre/i.test(pre.nodeName)) return;\n        if (!pre.hasAttribute(\"data-label\")) return;\n        var element;\n        var template;\n        var text = pre.getAttribute(\"data-label\");\n        try {\n            // Any normal text will blow up this selector.\n            template = document.querySelector(\"template#\" + text);\n        } catch (e) {}\n        if (template) element = template.content;\n        else {\n            if (pre.hasAttribute(\"data-url\")) {\n                element = document.createElement(\"a\");\n                element.href = pre.getAttribute(\"data-url\");\n            } else element = document.createElement(\"span\");\n            element.textContent = text;\n        }\n        return element;\n    });\n    /**\n\t * Register the toolbar with Prism.\n\t */ Prism.hooks.add(\"complete\", hook);\n})();\n(function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\") return;\n    if (!Prism.plugins.toolbar) {\n        console.warn(\"Copy to Clipboard plugin loaded before Toolbar plugin.\");\n        return;\n    }\n    /**\n\t * When the given elements is clicked by the user, the given text will be copied to clipboard.\n\t *\n\t * @param {HTMLElement} element\n\t * @param {CopyInfo} copyInfo\n\t *\n\t * @typedef CopyInfo\n\t * @property {() => string} getText\n\t * @property {() => void} success\n\t * @property {(reason: unknown) => void} error\n\t */ function registerClipboard(element, copyInfo) {\n        element.addEventListener(\"click\", function() {\n            copyTextToClipboard(copyInfo);\n        });\n    }\n    // https://stackoverflow.com/a/30810322/7595472\n    /** @param {CopyInfo} copyInfo */ function fallbackCopyTextToClipboard(copyInfo) {\n        var textArea = document.createElement(\"textarea\");\n        textArea.value = copyInfo.getText();\n        // Avoid scrolling to bottom\n        textArea.style.top = \"0\";\n        textArea.style.left = \"0\";\n        textArea.style.position = \"fixed\";\n        document.body.appendChild(textArea);\n        textArea.focus();\n        textArea.select();\n        try {\n            var successful = document.execCommand(\"copy\");\n            setTimeout(function() {\n                if (successful) copyInfo.success();\n                else copyInfo.error();\n            }, 1);\n        } catch (err) {\n            setTimeout(function() {\n                copyInfo.error(err);\n            }, 1);\n        }\n        document.body.removeChild(textArea);\n    }\n    /** @param {CopyInfo} copyInfo */ function copyTextToClipboard(copyInfo) {\n        if (navigator.clipboard) navigator.clipboard.writeText(copyInfo.getText()).then(copyInfo.success, function() {\n            // try the fallback in case `writeText` didn't work\n            fallbackCopyTextToClipboard(copyInfo);\n        });\n        else fallbackCopyTextToClipboard(copyInfo);\n    }\n    /**\n\t * Selects the text content of the given element.\n\t *\n\t * @param {Element} element\n\t */ function selectElementText(element) {\n        // https://stackoverflow.com/a/20079910/7595472\n        window.getSelection().selectAllChildren(element);\n    }\n    /**\n\t * Traverses up the DOM tree to find data attributes that override the default plugin settings.\n\t *\n\t * @param {Element} startElement An element to start from.\n\t * @returns {Settings} The plugin settings.\n\t * @typedef {Record<\"copy\" | \"copy-error\" | \"copy-success\" | \"copy-timeout\", string | number>} Settings\n\t */ function getSettings(startElement) {\n        /** @type {Settings} */ var settings = {\n            \"copy\": \"Copy\",\n            \"copy-error\": \"Press Ctrl+C to copy\",\n            \"copy-success\": \"Copied!\",\n            \"copy-timeout\": 5000\n        };\n        var prefix = \"data-prismjs-\";\n        for(var key in settings){\n            var attr = prefix + key;\n            var element = startElement;\n            while(element && !element.hasAttribute(attr))element = element.parentElement;\n            if (element) settings[key] = element.getAttribute(attr);\n        }\n        return settings;\n    }\n    Prism.plugins.toolbar.registerButton(\"copy-to-clipboard\", function(env) {\n        var element = env.element;\n        var settings = getSettings(element);\n        var linkCopy = document.createElement(\"button\");\n        linkCopy.className = \"copy-to-clipboard-button\";\n        linkCopy.setAttribute(\"type\", \"button\");\n        var linkSpan = document.createElement(\"span\");\n        linkCopy.appendChild(linkSpan);\n        setState(\"copy\");\n        registerClipboard(linkCopy, {\n            getText: function getText() {\n                return element.textContent;\n            },\n            success: function success() {\n                setState(\"copy-success\");\n                resetText();\n            },\n            error: function error() {\n                setState(\"copy-error\");\n                setTimeout(function() {\n                    selectElementText(element);\n                }, 1);\n                resetText();\n            }\n        });\n        return linkCopy;\n        function resetText() {\n            setTimeout(function() {\n                setState(\"copy\");\n            }, settings[\"copy-timeout\"]);\n        }\n        /** @param {\"copy\" | \"copy-error\" | \"copy-success\"} state */ function setState(state) {\n            linkSpan.textContent = settings[state];\n            linkCopy.setAttribute(\"data-copy-state\", state);\n        }\n    });\n})();\n(function() {\n    if (typeof Prism === \"undefined\" || typeof document === \"undefined\") return;\n    function mapClassName(name) {\n        var customClass = Prism.plugins.customClass;\n        if (customClass) return customClass.apply(name, \"none\");\n        else return name;\n    }\n    var PARTNER = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\"\n    };\n    // The names for brace types.\n    // These names have two purposes: 1) they can be used for styling and 2) they are used to pair braces. Only braces\n    // of the same type are paired.\n    var NAMES = {\n        \"(\": \"brace-round\",\n        \"[\": \"brace-square\",\n        \"{\": \"brace-curly\"\n    };\n    // A map for brace aliases.\n    // This is useful for when some braces have a prefix/suffix as part of the punctuation token.\n    var BRACE_ALIAS_MAP = {\n        \"${\": \"{\"\n    };\n    var LEVEL_WARP = 12;\n    var pairIdCounter = 0;\n    var BRACE_ID_PATTERN = /^(pair-\\d+-)(close|open)$/;\n    /**\n\t * Returns the brace partner given one brace of a brace pair.\n\t *\n\t * @param {HTMLElement} brace\n\t * @returns {HTMLElement}\n\t */ function getPartnerBrace(brace) {\n        var match = BRACE_ID_PATTERN.exec(brace.id);\n        return document.querySelector(\"#\" + match[1] + (match[2] == \"open\" ? \"close\" : \"open\"));\n    }\n    /**\n\t * @this {HTMLElement}\n\t */ function hoverBrace() {\n        if (!Prism.util.isActive(this, \"brace-hover\", true)) return;\n        [\n            this,\n            getPartnerBrace(this)\n        ].forEach(function(e) {\n            e.classList.add(mapClassName(\"brace-hover\"));\n        });\n    }\n    /**\n\t * @this {HTMLElement}\n\t */ function leaveBrace() {\n        [\n            this,\n            getPartnerBrace(this)\n        ].forEach(function(e) {\n            e.classList.remove(mapClassName(\"brace-hover\"));\n        });\n    }\n    /**\n\t * @this {HTMLElement}\n\t */ function clickBrace() {\n        if (!Prism.util.isActive(this, \"brace-select\", true)) return;\n        [\n            this,\n            getPartnerBrace(this)\n        ].forEach(function(e) {\n            e.classList.add(mapClassName(\"brace-selected\"));\n        });\n    }\n    Prism.hooks.add(\"complete\", function(env) {\n        /** @type {HTMLElement} */ var code = env.element;\n        var pre = code.parentElement;\n        if (!pre || pre.tagName != \"PRE\") return;\n        // find the braces to match\n        /** @type {string[]} */ var toMatch = [];\n        if (Prism.util.isActive(code, \"match-braces\")) toMatch.push(\"(\", \"[\", \"{\");\n        if (toMatch.length == 0) // nothing to match\n        return;\n        if (!pre.__listenerAdded) {\n            // code blocks might be highlighted more than once\n            pre.addEventListener(\"mousedown\", function removeBraceSelected() {\n                // the code element might have been replaced\n                var code = pre.querySelector(\"code\");\n                var className = mapClassName(\"brace-selected\");\n                Array.prototype.slice.call(code.querySelectorAll(\".\" + className)).forEach(function(e) {\n                    e.classList.remove(className);\n                });\n            });\n            Object.defineProperty(pre, \"__listenerAdded\", {\n                value: true\n            });\n        }\n        /** @type {HTMLSpanElement[]} */ var punctuation = Array.prototype.slice.call(code.querySelectorAll(\"span.\" + mapClassName(\"token\") + \".\" + mapClassName(\"punctuation\")));\n        /** @type {{ index: number, open: boolean, element: HTMLElement }[]} */ var allBraces = [];\n        toMatch.forEach(function(open) {\n            var close = PARTNER[open];\n            var name = mapClassName(NAMES[open]);\n            /** @type {[number, number][]} */ var pairs = [];\n            /** @type {number[]} */ var openStack = [];\n            for(var i = 0; i < punctuation.length; i++){\n                var element = punctuation[i];\n                if (element.childElementCount == 0) {\n                    var text = element.textContent;\n                    text = BRACE_ALIAS_MAP[text] || text;\n                    if (text === open) {\n                        allBraces.push({\n                            index: i,\n                            open: true,\n                            element: element\n                        });\n                        element.classList.add(name);\n                        element.classList.add(mapClassName(\"brace-open\"));\n                        openStack.push(i);\n                    } else if (text === close) {\n                        allBraces.push({\n                            index: i,\n                            open: false,\n                            element: element\n                        });\n                        element.classList.add(name);\n                        element.classList.add(mapClassName(\"brace-close\"));\n                        if (openStack.length) pairs.push([\n                            i,\n                            openStack.pop()\n                        ]);\n                    }\n                }\n            }\n            pairs.forEach(function(pair) {\n                var pairId = \"pair-\" + pairIdCounter++ + \"-\";\n                var opening = punctuation[pair[0]];\n                var closing = punctuation[pair[1]];\n                opening.id = pairId + \"open\";\n                closing.id = pairId + \"close\";\n                [\n                    opening,\n                    closing\n                ].forEach(function(e) {\n                    e.addEventListener(\"mouseenter\", hoverBrace);\n                    e.addEventListener(\"mouseleave\", leaveBrace);\n                    e.addEventListener(\"click\", clickBrace);\n                });\n            });\n        });\n        var level = 0;\n        allBraces.sort(function(a, b) {\n            return a.index - b.index;\n        });\n        allBraces.forEach(function(brace) {\n            if (brace.open) {\n                brace.element.classList.add(mapClassName(\"brace-level-\" + (level % LEVEL_WARP + 1)));\n                level++;\n            } else {\n                level = Math.max(0, level - 1);\n                brace.element.classList.add(mapClassName(\"brace-level-\" + (level % LEVEL_WARP + 1)));\n            }\n        });\n    });\n})();\n\n//# sourceMappingURL=css--01-grid.554c191d.js.map\n","/* PrismJS 1.29.0\nhttps://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript+css-extras+git+regex+scss&plugins=line-numbers+previewers+normalize-whitespace+toolbar+copy-to-clipboard+match-braces */\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prism’s API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof global !== 'undefined') {\n\tglobal.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n;\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n(function (Prism) {\n\n\tvar string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n\tvar selectorInside;\n\n\tPrism.languages.css.selector = {\n\t\tpattern: Prism.languages.css.selector.pattern,\n\t\tlookbehind: true,\n\t\tinside: selectorInside = {\n\t\t\t'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n\t\t\t'pseudo-class': /:[-\\w]+/,\n\t\t\t'class': /\\.[-\\w]+/,\n\t\t\t'id': /#[-\\w]+/,\n\t\t\t'attribute': {\n\t\t\t\tpattern: RegExp('\\\\[(?:[^[\\\\]\"\\']|' + string.source + ')*\\\\]'),\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^\\[|\\]$/,\n\t\t\t\t\t'case-sensitivity': {\n\t\t\t\t\t\tpattern: /(\\s)[si]$/i,\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'keyword'\n\t\t\t\t\t},\n\t\t\t\t\t'namespace': {\n\t\t\t\t\t\tpattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\tinside: {\n\t\t\t\t\t\t\t'punctuation': /\\|$/\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t'attr-name': {\n\t\t\t\t\t\tpattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'attr-value': [\n\t\t\t\t\t\tstring,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t'operator': /[|~*^$]?=/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'n-th': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'number': /[\\dn]+/,\n\t\t\t\t\t\t'operator': /[+-]/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t],\n\t\t\t'combinator': />|\\+|~|\\|\\|/,\n\n\t\t\t// the `tag` token has been existed and removed.\n\t\t\t// because we can't find a perfect tokenize to match it.\n\t\t\t// if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.\n\n\t\t\t'punctuation': /[(),]/,\n\t\t}\n\t};\n\n\tPrism.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;\n\n\tPrism.languages.insertBefore('css', 'property', {\n\t\t'variable': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n\t\t\tlookbehind: true\n\t\t}\n\t});\n\n\tvar unit = {\n\t\tpattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n\t\tlookbehind: true\n\t};\n\t// 123 -123 .123 -.123 12.3 -12.3\n\tvar number = {\n\t\tpattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n\t\tlookbehind: true\n\t};\n\n\tPrism.languages.insertBefore('css', 'function', {\n\t\t'operator': {\n\t\t\tpattern: /(\\s)[+\\-*\\/](?=\\s)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t// CAREFUL!\n\t\t// Previewers and Inline color use hexcode and color.\n\t\t'hexcode': {\n\t\t\tpattern: /\\B#[\\da-f]{3,8}\\b/i,\n\t\t\talias: 'color'\n\t\t},\n\t\t'color': [\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n\t\t\t\tinside: {\n\t\t\t\t\t'unit': unit,\n\t\t\t\t\t'number': number,\n\t\t\t\t\t'function': /[\\w-]+(?=\\()/,\n\t\t\t\t\t'punctuation': /[(),]/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t// it's important that there is no boundary assertion after the hex digits\n\t\t'entity': /\\\\[\\da-f]{1,8}/i,\n\t\t'unit': unit,\n\t\t'number': number\n\t});\n\n}(Prism));\n\nPrism.languages.git = {\n\t/*\n\t * A simple one line comment like in a git status command\n\t * For instance:\n\t * $ git status\n\t * # On branch infinite-scroll\n\t * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n\t * # and have 1 and 2 different commits each, respectively.\n\t * nothing to commit (working directory clean)\n\t */\n\t'comment': /^#.*/m,\n\n\t/*\n\t * Regexp to match the changed lines in a git diff output. Check the example below.\n\t */\n\t'deleted': /^[-–].*/m,\n\t'inserted': /^\\+.*/m,\n\n\t/*\n\t * a string (double and simple quote)\n\t */\n\t'string': /(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\n\t/*\n\t * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n\t * For instance:\n\t * $ git add file.txt\n\t */\n\t'command': {\n\t\tpattern: /^.*\\$ git .*$/m,\n\t\tinside: {\n\t\t\t/*\n\t\t\t * A git command can contain a parameter starting by a single or a double dash followed by a string\n\t\t\t * For instance:\n\t\t\t * $ git diff --cached\n\t\t\t * $ git log -p\n\t\t\t */\n\t\t\t'parameter': /\\s--?\\w+/\n\t\t}\n\t},\n\n\t/*\n\t * Coordinates displayed in a git diff command\n\t * For instance:\n\t * $ git diff\n\t * diff --git file.txt file.txt\n\t * index 6214953..1d54a52 100644\n\t * --- file.txt\n\t * +++ file.txt\n\t * @@ -1 +1,2 @@\n\t * -Here's my tetx file\n\t * +Here's my text file\n\t * +And this is the second line\n\t */\n\t'coord': /^@@.*@@$/m,\n\n\t/*\n\t * Match a \"commit [SHA1]\" line in a git log output.\n\t * For instance:\n\t * $ git log\n\t * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n\t * Author: lgiraudel\n\t * Date:   Mon Feb 17 11:18:34 2014 +0100\n\t *\n\t *     Add of a new line\n\t */\n\t'commit-sha1': /^commit \\w{40}$/m\n};\n\n(function (Prism) {\n\n\tvar specialEscape = {\n\t\tpattern: /\\\\[\\\\(){}[\\]^$+*?|.]/,\n\t\talias: 'escape'\n\t};\n\tvar escape = /\\\\(?:x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u\\{[\\da-fA-F]+\\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;\n\tvar charSet = {\n\t\tpattern: /\\.|\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n\t\talias: 'class-name'\n\t};\n\tvar charSetWithoutDot = {\n\t\tpattern: /\\\\[wsd]|\\\\p\\{[^{}]+\\}/i,\n\t\talias: 'class-name'\n\t};\n\n\tvar rangeChar = '(?:[^\\\\\\\\-]|' + escape.source + ')';\n\tvar range = RegExp(rangeChar + '-' + rangeChar);\n\n\t// the name of a capturing group\n\tvar groupName = {\n\t\tpattern: /(<|')[^<>']+(?=[>']$)/,\n\t\tlookbehind: true,\n\t\talias: 'variable'\n\t};\n\n\tPrism.languages.regex = {\n\t\t'char-class': {\n\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\\\\\)*)\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/,\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'char-class-negation': {\n\t\t\t\t\tpattern: /(^\\[)\\^/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'char-class-punctuation': {\n\t\t\t\t\tpattern: /^\\[|\\]$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'range': {\n\t\t\t\t\tpattern: range,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'escape': escape,\n\t\t\t\t\t\t'range-punctuation': {\n\t\t\t\t\t\t\tpattern: /-/,\n\t\t\t\t\t\t\talias: 'operator'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'special-escape': specialEscape,\n\t\t\t\t'char-set': charSetWithoutDot,\n\t\t\t\t'escape': escape\n\t\t\t}\n\t\t},\n\t\t'special-escape': specialEscape,\n\t\t'char-set': charSet,\n\t\t'backreference': [\n\t\t\t{\n\t\t\t\t// a backreference which is not an octal escape\n\t\t\t\tpattern: /\\\\(?![123][0-7]{2})[1-9]/,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\\\k<[^<>']+>/,\n\t\t\t\talias: 'keyword',\n\t\t\t\tinside: {\n\t\t\t\t\t'group-name': groupName\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'anchor': {\n\t\t\tpattern: /[$^]|\\\\[ABbGZz]/,\n\t\t\talias: 'function'\n\t\t},\n\t\t'escape': escape,\n\t\t'group': [\n\t\t\t{\n\t\t\t\t// https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html\n\t\t\t\t// https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs\n\n\t\t\t\t// (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)\n\t\t\t\tpattern: /\\((?:\\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,\n\t\t\t\talias: 'punctuation',\n\t\t\t\tinside: {\n\t\t\t\t\t'group-name': groupName\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /\\)/,\n\t\t\t\talias: 'punctuation'\n\t\t\t}\n\t\t],\n\t\t'quantifier': {\n\t\t\tpattern: /(?:[+*?]|\\{\\d+(?:,\\d*)?\\})[?+]?/,\n\t\t\talias: 'number'\n\t\t},\n\t\t'alternation': {\n\t\t\tpattern: /\\|/,\n\t\t\talias: 'keyword'\n\t\t}\n\t};\n\n}(Prism));\n\nPrism.languages.scss = Prism.languages.extend('css', {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n\t\tlookbehind: true\n\t},\n\t'atrule': {\n\t\tpattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n\t\tinside: {\n\t\t\t'rule': /@[\\w-]+/\n\t\t\t// See rest below\n\t\t}\n\t},\n\t// url, compassified\n\t'url': /(?:[-a-z]+-)?url(?=\\()/i,\n\t// CSS selector regex is not appropriate for Sass\n\t// since there can be lot more things (var, @ directive, nesting..)\n\t// a selector must start at the end of a property or after a brace (end of other rules or nesting)\n\t// it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n\t// the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n\t// can \"pass\" as a selector- e.g: proper#{$erty})\n\t// this one was hard to do, so please be careful if you edit this one :)\n\t'selector': {\n\t\t// Initial look-ahead is used to prevent matching of blank selectors\n\t\tpattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n\t\tinside: {\n\t\t\t'parent': {\n\t\t\t\tpattern: /&/,\n\t\t\t\talias: 'important'\n\t\t\t},\n\t\t\t'placeholder': /%[-\\w]+/,\n\t\t\t'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n\t\t}\n\t},\n\t'property': {\n\t\tpattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n\t\tinside: {\n\t\t\t'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('scss', 'atrule', {\n\t'keyword': [\n\t\t/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i,\n\t\t{\n\t\t\tpattern: /( )(?:from|through)(?= )/,\n\t\t\tlookbehind: true\n\t\t}\n\t]\n});\n\nPrism.languages.insertBefore('scss', 'important', {\n\t// var and interpolated vars\n\t'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\n\nPrism.languages.insertBefore('scss', 'function', {\n\t'module-modifier': {\n\t\tpattern: /\\b(?:as|hide|show|with)\\b/i,\n\t\talias: 'keyword'\n\t},\n\t'placeholder': {\n\t\tpattern: /%[-\\w]+/,\n\t\talias: 'selector'\n\t},\n\t'statement': {\n\t\tpattern: /\\B!(?:default|optional)\\b/i,\n\t\talias: 'keyword'\n\t},\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'null': {\n\t\tpattern: /\\bnull\\b/,\n\t\talias: 'keyword'\n\t},\n\t'operator': {\n\t\tpattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n\t\tlookbehind: true\n\t}\n});\n\nPrism.languages.scss['atrule'].inside.rest = Prism.languages.scss;\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t/**\n\t * Plugin name which is used as a class name for <pre> which is activating the plugin\n\t *\n\t * @type {string}\n\t */\n\tvar PLUGIN_NAME = 'line-numbers';\n\n\t/**\n\t * Regular expression used for determining line breaks\n\t *\n\t * @type {RegExp}\n\t */\n\tvar NEW_LINE_EXP = /\\n(?!$)/g;\n\n\n\t/**\n\t * Global exports\n\t */\n\tvar config = Prism.plugins.lineNumbers = {\n\t\t/**\n\t\t * Get node for provided line number\n\t\t *\n\t\t * @param {Element} element pre element\n\t\t * @param {number} number line number\n\t\t * @returns {Element|undefined}\n\t\t */\n\t\tgetLine: function (element, number) {\n\t\t\tif (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lineNumberRows = element.querySelector('.line-numbers-rows');\n\t\t\tif (!lineNumberRows) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;\n\t\t\tvar lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);\n\n\t\t\tif (number < lineNumberStart) {\n\t\t\t\tnumber = lineNumberStart;\n\t\t\t}\n\t\t\tif (number > lineNumberEnd) {\n\t\t\t\tnumber = lineNumberEnd;\n\t\t\t}\n\n\t\t\tvar lineIndex = number - lineNumberStart;\n\n\t\t\treturn lineNumberRows.children[lineIndex];\n\t\t},\n\n\t\t/**\n\t\t * Resizes the line numbers of the given element.\n\t\t *\n\t\t * This function will not add line numbers. It will only resize existing ones.\n\t\t *\n\t\t * @param {HTMLElement} element A `<pre>` element with line numbers.\n\t\t * @returns {void}\n\t\t */\n\t\tresize: function (element) {\n\t\t\tresizeElements([element]);\n\t\t},\n\n\t\t/**\n\t\t * Whether the plugin can assume that the units font sizes and margins are not depended on the size of\n\t\t * the current viewport.\n\t\t *\n\t\t * Setting this to `true` will allow the plugin to do certain optimizations for better performance.\n\t\t *\n\t\t * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.\n\t\t *\n\t\t * @type {boolean}\n\t\t */\n\t\tassumeViewportIndependence: true\n\t};\n\n\t/**\n\t * Resizes the given elements.\n\t *\n\t * @param {HTMLElement[]} elements\n\t */\n\tfunction resizeElements(elements) {\n\t\telements = elements.filter(function (e) {\n\t\t\tvar codeStyles = getStyles(e);\n\t\t\tvar whiteSpace = codeStyles['white-space'];\n\t\t\treturn whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line';\n\t\t});\n\n\t\tif (elements.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar infos = elements.map(function (element) {\n\t\t\tvar codeElement = element.querySelector('code');\n\t\t\tvar lineNumbersWrapper = element.querySelector('.line-numbers-rows');\n\t\t\tif (!codeElement || !lineNumbersWrapper) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t/** @type {HTMLElement} */\n\t\t\tvar lineNumberSizer = element.querySelector('.line-numbers-sizer');\n\t\t\tvar codeLines = codeElement.textContent.split(NEW_LINE_EXP);\n\n\t\t\tif (!lineNumberSizer) {\n\t\t\t\tlineNumberSizer = document.createElement('span');\n\t\t\t\tlineNumberSizer.className = 'line-numbers-sizer';\n\n\t\t\t\tcodeElement.appendChild(lineNumberSizer);\n\t\t\t}\n\n\t\t\tlineNumberSizer.innerHTML = '0';\n\t\t\tlineNumberSizer.style.display = 'block';\n\n\t\t\tvar oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;\n\t\t\tlineNumberSizer.innerHTML = '';\n\n\t\t\treturn {\n\t\t\t\telement: element,\n\t\t\t\tlines: codeLines,\n\t\t\t\tlineHeights: [],\n\t\t\t\toneLinerHeight: oneLinerHeight,\n\t\t\t\tsizer: lineNumberSizer,\n\t\t\t};\n\t\t}).filter(Boolean);\n\n\t\tinfos.forEach(function (info) {\n\t\t\tvar lineNumberSizer = info.sizer;\n\t\t\tvar lines = info.lines;\n\t\t\tvar lineHeights = info.lineHeights;\n\t\t\tvar oneLinerHeight = info.oneLinerHeight;\n\n\t\t\tlineHeights[lines.length - 1] = undefined;\n\t\t\tlines.forEach(function (line, index) {\n\t\t\t\tif (line && line.length > 1) {\n\t\t\t\t\tvar e = lineNumberSizer.appendChild(document.createElement('span'));\n\t\t\t\t\te.style.display = 'block';\n\t\t\t\t\te.textContent = line;\n\t\t\t\t} else {\n\t\t\t\t\tlineHeights[index] = oneLinerHeight;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tinfos.forEach(function (info) {\n\t\t\tvar lineNumberSizer = info.sizer;\n\t\t\tvar lineHeights = info.lineHeights;\n\n\t\t\tvar childIndex = 0;\n\t\t\tfor (var i = 0; i < lineHeights.length; i++) {\n\t\t\t\tif (lineHeights[i] === undefined) {\n\t\t\t\t\tlineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tinfos.forEach(function (info) {\n\t\t\tvar lineNumberSizer = info.sizer;\n\t\t\tvar wrapper = info.element.querySelector('.line-numbers-rows');\n\n\t\t\tlineNumberSizer.style.display = 'none';\n\t\t\tlineNumberSizer.innerHTML = '';\n\n\t\t\tinfo.lineHeights.forEach(function (height, lineNumber) {\n\t\t\t\twrapper.children[lineNumber].style.height = height + 'px';\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Returns style declarations for the element\n\t *\n\t * @param {Element} element\n\t */\n\tfunction getStyles(element) {\n\t\tif (!element) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);\n\t}\n\n\tvar lastWidth = undefined;\n\twindow.addEventListener('resize', function () {\n\t\tif (config.assumeViewportIndependence && lastWidth === window.innerWidth) {\n\t\t\treturn;\n\t\t}\n\t\tlastWidth = window.innerWidth;\n\n\t\tresizeElements(Array.prototype.slice.call(document.querySelectorAll('pre.' + PLUGIN_NAME)));\n\t});\n\n\tPrism.hooks.add('complete', function (env) {\n\t\tif (!env.code) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar code = /** @type {Element} */ (env.element);\n\t\tvar pre = /** @type {HTMLElement} */ (code.parentNode);\n\n\t\t// works only for <code> wrapped inside <pre> (not inline)\n\t\tif (!pre || !/pre/i.test(pre.nodeName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Abort if line numbers already exists\n\t\tif (code.querySelector('.line-numbers-rows')) {\n\t\t\treturn;\n\t\t}\n\n\t\t// only add line numbers if <code> or one of its ancestors has the `line-numbers` class\n\t\tif (!Prism.util.isActive(code, PLUGIN_NAME)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove the class 'line-numbers' from the <code>\n\t\tcode.classList.remove(PLUGIN_NAME);\n\t\t// Add the class 'line-numbers' to the <pre>\n\t\tpre.classList.add(PLUGIN_NAME);\n\n\t\tvar match = env.code.match(NEW_LINE_EXP);\n\t\tvar linesNum = match ? match.length + 1 : 1;\n\t\tvar lineNumbersWrapper;\n\n\t\tvar lines = new Array(linesNum + 1).join('<span></span>');\n\n\t\tlineNumbersWrapper = document.createElement('span');\n\t\tlineNumbersWrapper.setAttribute('aria-hidden', 'true');\n\t\tlineNumbersWrapper.className = 'line-numbers-rows';\n\t\tlineNumbersWrapper.innerHTML = lines;\n\n\t\tif (pre.hasAttribute('data-start')) {\n\t\t\tpre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);\n\t\t}\n\n\t\tenv.element.appendChild(lineNumbersWrapper);\n\n\t\tresizeElements([pre]);\n\n\t\tPrism.hooks.run('line-numbers', env);\n\t});\n\n\tPrism.hooks.add('line-numbers', function (env) {\n\t\tenv.plugins = env.plugins || {};\n\t\tenv.plugins.lineNumbers = true;\n\t});\n\n}());\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined' || !Function.prototype.bind) {\n\t\treturn;\n\t}\n\n\tvar previewers = {\n\t\t// gradient must be defined before color and angle\n\t\t'gradient': {\n\t\t\tcreate: (function () {\n\n\t\t\t\t// Stores already processed gradients so that we don't\n\t\t\t\t// make the conversion every time the previewer is shown\n\t\t\t\tvar cache = {};\n\n\t\t\t\t/**\n\t\t\t\t * Returns a W3C-valid linear gradient\n\t\t\t\t *\n\t\t\t\t * @param {string} prefix Vendor prefix if any (\"-moz-\", \"-webkit-\", etc.)\n\t\t\t\t * @param {string} func Gradient function name (\"linear-gradient\")\n\t\t\t\t * @param {string[]} values Array of the gradient function parameters ([\"0deg\", \"red 0%\", \"blue 100%\"])\n\t\t\t\t */\n\t\t\t\tvar convertToW3CLinearGradient = function (prefix, func, values) {\n\t\t\t\t\t// Default value for angle\n\t\t\t\t\tvar angle = '180deg';\n\n\t\t\t\t\tif (/^(?:-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:deg|rad)|to\\b|top|right|bottom|left)/.test(values[0])) {\n\t\t\t\t\t\tangle = values.shift();\n\t\t\t\t\t\tif (angle.indexOf('to ') < 0) {\n\t\t\t\t\t\t\t// Angle uses old keywords\n\t\t\t\t\t\t\t// W3C syntax uses \"to\" + opposite keywords\n\t\t\t\t\t\t\tif (angle.indexOf('top') >= 0) {\n\t\t\t\t\t\t\t\tif (angle.indexOf('left') >= 0) {\n\t\t\t\t\t\t\t\t\tangle = 'to bottom right';\n\t\t\t\t\t\t\t\t} else if (angle.indexOf('right') >= 0) {\n\t\t\t\t\t\t\t\t\tangle = 'to bottom left';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tangle = 'to bottom';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (angle.indexOf('bottom') >= 0) {\n\t\t\t\t\t\t\t\tif (angle.indexOf('left') >= 0) {\n\t\t\t\t\t\t\t\t\tangle = 'to top right';\n\t\t\t\t\t\t\t\t} else if (angle.indexOf('right') >= 0) {\n\t\t\t\t\t\t\t\t\tangle = 'to top left';\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tangle = 'to top';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (angle.indexOf('left') >= 0) {\n\t\t\t\t\t\t\t\tangle = 'to right';\n\t\t\t\t\t\t\t} else if (angle.indexOf('right') >= 0) {\n\t\t\t\t\t\t\t\tangle = 'to left';\n\t\t\t\t\t\t\t} else if (prefix) {\n\t\t\t\t\t\t\t\t// Angle is shifted by 90deg in prefixed gradients\n\t\t\t\t\t\t\t\tif (angle.indexOf('deg') >= 0) {\n\t\t\t\t\t\t\t\t\tangle = (90 - parseFloat(angle)) + 'deg';\n\t\t\t\t\t\t\t\t} else if (angle.indexOf('rad') >= 0) {\n\t\t\t\t\t\t\t\t\tangle = (Math.PI / 2 - parseFloat(angle)) + 'rad';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn func + '(' + angle + ',' + values.join(',') + ')';\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Returns a W3C-valid radial gradient\n\t\t\t\t *\n\t\t\t\t * @param {string} prefix Vendor prefix if any (\"-moz-\", \"-webkit-\", etc.)\n\t\t\t\t * @param {string} func Gradient function name (\"linear-gradient\")\n\t\t\t\t * @param {string[]} values Array of the gradient function parameters ([\"0deg\", \"red 0%\", \"blue 100%\"])\n\t\t\t\t */\n\t\t\t\tvar convertToW3CRadialGradient = function (prefix, func, values) {\n\t\t\t\t\tif (values[0].indexOf('at') < 0) {\n\t\t\t\t\t\t// Looks like old syntax\n\n\t\t\t\t\t\t// Default values\n\t\t\t\t\t\tvar position = 'center';\n\t\t\t\t\t\tvar shape = 'ellipse';\n\t\t\t\t\t\tvar size = 'farthest-corner';\n\n\t\t\t\t\t\tif (/\\b(?:bottom|center|left|right|top)\\b|^\\d+/.test(values[0])) {\n\t\t\t\t\t\t\t// Found a position\n\t\t\t\t\t\t\t// Remove angle value, if any\n\t\t\t\t\t\t\tposition = values.shift().replace(/\\s*-?\\d+(?:deg|rad)\\s*/, '');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (/\\b(?:circle|closest|contain|cover|ellipse|farthest)\\b/.test(values[0])) {\n\t\t\t\t\t\t\t// Found a shape and/or size\n\t\t\t\t\t\t\tvar shapeSizeParts = values.shift().split(/\\s+/);\n\t\t\t\t\t\t\tif (shapeSizeParts[0] && (shapeSizeParts[0] === 'circle' || shapeSizeParts[0] === 'ellipse')) {\n\t\t\t\t\t\t\t\tshape = shapeSizeParts.shift();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (shapeSizeParts[0]) {\n\t\t\t\t\t\t\t\tsize = shapeSizeParts.shift();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Old keywords are converted to their synonyms\n\t\t\t\t\t\t\tif (size === 'cover') {\n\t\t\t\t\t\t\t\tsize = 'farthest-corner';\n\t\t\t\t\t\t\t} else if (size === 'contain') {\n\t\t\t\t\t\t\t\tsize = 'clothest-side';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn func + '(' + shape + ' ' + size + ' at ' + position + ',' + values.join(',') + ')';\n\t\t\t\t\t}\n\t\t\t\t\treturn func + '(' + values.join(',') + ')';\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * Converts a gradient to a W3C-valid one\n\t\t\t\t * Does not support old webkit syntax (-webkit-gradient(linear...) and -webkit-gradient(radial...))\n\t\t\t\t *\n\t\t\t\t * @param {string} gradient The CSS gradient\n\t\t\t\t */\n\t\t\t\tvar convertToW3CGradient = function (gradient) {\n\t\t\t\t\tif (cache[gradient]) {\n\t\t\t\t\t\treturn cache[gradient];\n\t\t\t\t\t}\n\t\t\t\t\tvar parts = gradient.match(/^(\\b|\\B-[a-z]{1,10}-)((?:repeating-)?(?:linear|radial)-gradient)/);\n\t\t\t\t\t// \"\", \"-moz-\", etc.\n\t\t\t\t\tvar prefix = parts && parts[1];\n\t\t\t\t\t// \"linear-gradient\", \"radial-gradient\", etc.\n\t\t\t\t\tvar func = parts && parts[2];\n\n\t\t\t\t\tvar values = gradient.replace(/^(?:\\b|\\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\\(|\\)$/g, '').split(/\\s*,\\s*/);\n\n\t\t\t\t\tif (func.indexOf('linear') >= 0) {\n\t\t\t\t\t\treturn cache[gradient] = convertToW3CLinearGradient(prefix, func, values);\n\t\t\t\t\t} else if (func.indexOf('radial') >= 0) {\n\t\t\t\t\t\treturn cache[gradient] = convertToW3CRadialGradient(prefix, func, values);\n\t\t\t\t\t}\n\t\t\t\t\treturn cache[gradient] = func + '(' + values.join(',') + ')';\n\t\t\t\t};\n\n\t\t\t\treturn function () {\n\t\t\t\t\tnew Prism.plugins.Previewer('gradient', function (value) {\n\t\t\t\t\t\tthis.firstChild.style.backgroundImage = '';\n\t\t\t\t\t\tthis.firstChild.style.backgroundImage = convertToW3CGradient(value);\n\t\t\t\t\t\treturn !!this.firstChild.style.backgroundImage;\n\t\t\t\t\t}, '*', function () {\n\t\t\t\t\t\tthis._elt.innerHTML = '<div></div>';\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}()),\n\t\t\ttokens: {\n\t\t\t\t'gradient': {\n\t\t\t\t\tpattern: /(?:\\b|\\B-[a-z]{1,10}-)(?:repeating-)?(?:linear|radial)-gradient\\((?:(?:hsl|rgb)a?\\(.+?\\)|[^\\)])+\\)/gi,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'function': /[\\w-]+(?=\\()/,\n\t\t\t\t\t\t'punctuation': /[(),]/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tlanguages: {\n\t\t\t\t'css': true,\n\t\t\t\t'less': true,\n\t\t\t\t'sass': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['variable-line']\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['property-line']\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'scss': true,\n\t\t\t\t'stylus': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'func',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['property-declaration'].inside\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'func',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['variable-declaration'].inside\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t},\n\t\t'angle': {\n\t\t\tcreate: function () {\n\t\t\t\tnew Prism.plugins.Previewer('angle', function (value) {\n\t\t\t\t\tvar num = parseFloat(value);\n\t\t\t\t\tvar unit = value.match(/[a-z]+$/i);\n\t\t\t\t\tvar max; var percentage;\n\t\t\t\t\tif (!num || !unit) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tunit = unit[0];\n\n\t\t\t\t\tswitch (unit) {\n\t\t\t\t\t\tcase 'deg':\n\t\t\t\t\t\t\tmax = 360;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'grad':\n\t\t\t\t\t\t\tmax = 400;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'rad':\n\t\t\t\t\t\t\tmax = 2 * Math.PI;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'turn':\n\t\t\t\t\t\t\tmax = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tpercentage = 100 * num / max;\n\t\t\t\t\tpercentage %= 100;\n\n\t\t\t\t\tthis[(num < 0 ? 'set' : 'remove') + 'Attribute']('data-negative', '');\n\t\t\t\t\tthis.querySelector('circle').style.strokeDasharray = Math.abs(percentage) + ',500';\n\t\t\t\t\treturn true;\n\t\t\t\t}, '*', function () {\n\t\t\t\t\tthis._elt.innerHTML = '<svg viewBox=\"0 0 64 64\">' +\n\t\t\t\t\t\t'<circle r=\"16\" cy=\"32\" cx=\"32\"></circle>' +\n\t\t\t\t\t\t'</svg>';\n\t\t\t\t});\n\t\t\t},\n\t\t\ttokens: {\n\t\t\t\t'angle': /(?:\\b|\\B-|(?=\\B\\.))(?:\\d+(?:\\.\\d+)?|\\.\\d+)(?:deg|g?rad|turn)\\b/i\n\t\t\t},\n\t\t\tlanguages: {\n\t\t\t\t'css': true,\n\t\t\t\t'less': true,\n\t\t\t\t'markup': {\n\t\t\t\t\tlang: 'markup',\n\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\tinside: 'inside',\n\t\t\t\t\troot: Prism.languages.markup && Prism.languages.markup['tag'].inside['attr-value']\n\t\t\t\t},\n\t\t\t\t'sass': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['property-line']\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tbefore: 'operator',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['variable-line']\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'scss': true,\n\t\t\t\t'stylus': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'func',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['property-declaration'].inside\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'func',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['variable-declaration'].inside\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t},\n\t\t'color': {\n\t\t\tcreate: function () {\n\t\t\t\tnew Prism.plugins.Previewer('color', function (value) {\n\t\t\t\t\tthis.style.backgroundColor = '';\n\t\t\t\t\tthis.style.backgroundColor = value;\n\t\t\t\t\treturn !!this.style.backgroundColor;\n\t\t\t\t});\n\t\t\t},\n\t\t\ttokens: {\n\t\t\t\t'color': [Prism.languages.css['hexcode']].concat(Prism.languages.css['color'])\n\t\t\t},\n\t\t\tlanguages: {\n\t\t\t\t// CSS extras is required, so css and scss are not necessary\n\t\t\t\t'css': false,\n\t\t\t\t'less': true,\n\t\t\t\t'markup': {\n\t\t\t\t\tlang: 'markup',\n\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\tinside: 'inside',\n\t\t\t\t\troot: Prism.languages.markup && Prism.languages.markup['tag'].inside['attr-value']\n\t\t\t\t},\n\t\t\t\t'sass': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['variable-line']\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['property-line']\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'scss': false,\n\t\t\t\t'stylus': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'hexcode',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['property-declaration'].inside\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'hexcode',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['variable-declaration'].inside\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t},\n\t\t'easing': {\n\t\t\tcreate: function () {\n\t\t\t\tnew Prism.plugins.Previewer('easing', function (value) {\n\n\t\t\t\t\tvalue = {\n\t\t\t\t\t\t'linear': '0,0,1,1',\n\t\t\t\t\t\t'ease': '.25,.1,.25,1',\n\t\t\t\t\t\t'ease-in': '.42,0,1,1',\n\t\t\t\t\t\t'ease-out': '0,0,.58,1',\n\t\t\t\t\t\t'ease-in-out': '.42,0,.58,1'\n\t\t\t\t\t}[value] || value;\n\n\t\t\t\t\tvar p = value.match(/-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/g);\n\n\t\t\t\t\tif (p.length === 4) {\n\t\t\t\t\t\tp = p.map(function (p, i) { return (i % 2 ? 1 - p : p) * 100; });\n\n\t\t\t\t\t\tthis.querySelector('path').setAttribute('d', 'M0,100 C' + p[0] + ',' + p[1] + ', ' + p[2] + ',' + p[3] + ', 100,0');\n\n\t\t\t\t\t\tvar lines = this.querySelectorAll('line');\n\t\t\t\t\t\tlines[0].setAttribute('x2', p[0]);\n\t\t\t\t\t\tlines[0].setAttribute('y2', p[1]);\n\t\t\t\t\t\tlines[1].setAttribute('x2', p[2]);\n\t\t\t\t\t\tlines[1].setAttribute('y2', p[3]);\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}, '*', function () {\n\t\t\t\t\tthis._elt.innerHTML = '<svg viewBox=\"-20 -20 140 140\" width=\"100\" height=\"100\">' +\n\t\t\t\t\t\t'<defs>' +\n\t\t\t\t\t\t'<marker id=\"prism-previewer-easing-marker\" viewBox=\"0 0 4 4\" refX=\"2\" refY=\"2\" markerUnits=\"strokeWidth\">' +\n\t\t\t\t\t\t'<circle cx=\"2\" cy=\"2\" r=\"1.5\" />' +\n\t\t\t\t\t\t'</marker>' +\n\t\t\t\t\t\t'</defs>' +\n\t\t\t\t\t\t'<path d=\"M0,100 C20,50, 40,30, 100,0\" />' +\n\t\t\t\t\t\t'<line x1=\"0\" y1=\"100\" x2=\"20\" y2=\"50\" marker-start=\"url(#prism-previewer-easing-marker)\" marker-end=\"url(#prism-previewer-easing-marker)\" />' +\n\t\t\t\t\t\t'<line x1=\"100\" y1=\"0\" x2=\"40\" y2=\"30\" marker-start=\"url(#prism-previewer-easing-marker)\" marker-end=\"url(#prism-previewer-easing-marker)\" />' +\n\t\t\t\t\t\t'</svg>';\n\t\t\t\t});\n\t\t\t},\n\t\t\ttokens: {\n\t\t\t\t'easing': {\n\t\t\t\t\tpattern: /\\bcubic-bezier\\((?:-?(?:\\d+(?:\\.\\d+)?|\\.\\d+),\\s*){3}-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)\\)\\B|\\b(?:ease(?:-in)?(?:-out)?|linear)(?=\\s|[;}]|$)/i,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'function': /[\\w-]+(?=\\()/,\n\t\t\t\t\t\t'punctuation': /[(),]/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tlanguages: {\n\t\t\t\t'css': true,\n\t\t\t\t'less': true,\n\t\t\t\t'sass': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['variable-line']\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['property-line']\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'scss': true,\n\t\t\t\t'stylus': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'hexcode',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['property-declaration'].inside\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'hexcode',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['variable-declaration'].inside\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t},\n\n\t\t'time': {\n\t\t\tcreate: function () {\n\t\t\t\tnew Prism.plugins.Previewer('time', function (value) {\n\t\t\t\t\tvar num = parseFloat(value);\n\t\t\t\t\tvar unit = value.match(/[a-z]+$/i);\n\t\t\t\t\tif (!num || !unit) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tunit = unit[0];\n\t\t\t\t\tthis.querySelector('circle').style.animationDuration = 2 * num + unit;\n\t\t\t\t\treturn true;\n\t\t\t\t}, '*', function () {\n\t\t\t\t\tthis._elt.innerHTML = '<svg viewBox=\"0 0 64 64\">' +\n\t\t\t\t\t\t'<circle r=\"16\" cy=\"32\" cx=\"32\"></circle>' +\n\t\t\t\t\t\t'</svg>';\n\t\t\t\t});\n\t\t\t},\n\t\t\ttokens: {\n\t\t\t\t'time': /(?:\\b|\\B-|(?=\\B\\.))(?:\\d+(?:\\.\\d+)?|\\.\\d+)m?s\\b/i\n\t\t\t},\n\t\t\tlanguages: {\n\t\t\t\t'css': true,\n\t\t\t\t'less': true,\n\t\t\t\t'markup': {\n\t\t\t\t\tlang: 'markup',\n\t\t\t\t\tbefore: 'punctuation',\n\t\t\t\t\tinside: 'inside',\n\t\t\t\t\troot: Prism.languages.markup && Prism.languages.markup['tag'].inside['attr-value']\n\t\t\t\t},\n\t\t\t\t'sass': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['property-line']\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'sass',\n\t\t\t\t\t\tbefore: 'operator',\n\t\t\t\t\t\tinside: 'inside',\n\t\t\t\t\t\troot: Prism.languages.sass && Prism.languages.sass['variable-line']\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t'scss': true,\n\t\t\t\t'stylus': [\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'hexcode',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['property-declaration'].inside\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tlang: 'stylus',\n\t\t\t\t\t\tbefore: 'hexcode',\n\t\t\t\t\t\tinside: 'rest',\n\t\t\t\t\t\troot: Prism.languages.stylus && Prism.languages.stylus['variable-declaration'].inside\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Returns the absolute X, Y offsets for an element\n\t *\n\t * @param {HTMLElement} element\n\t * @returns {{top: number, right: number, bottom: number, left: number, width: number, height: number}}\n\t */\n\tvar getOffset = function (element) {\n\t\tvar elementBounds = element.getBoundingClientRect();\n\t\tvar left = elementBounds.left;\n\t\tvar top = elementBounds.top;\n\t\tvar documentBounds = document.documentElement.getBoundingClientRect();\n\t\tleft -= documentBounds.left;\n\t\ttop -= documentBounds.top;\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tright: innerWidth - left - elementBounds.width,\n\t\t\tbottom: innerHeight - top - elementBounds.height,\n\t\t\tleft: left,\n\t\t\twidth: elementBounds.width,\n\t\t\theight: elementBounds.height\n\t\t};\n\t};\n\n\tvar TOKEN_CLASS = 'token';\n\tvar ACTIVE_CLASS = 'active';\n\tvar FLIPPED_CLASS = 'flipped';\n\n\t/**\n\t * Previewer constructor\n\t *\n\t * @param {string} type Unique previewer type\n\t * @param {Function} updater Function that will be called on mouseover.\n\t * @param {string[]|string} [supportedLanguages] Aliases of the languages this previewer must be enabled for. Defaults to \"*\", all languages.\n\t * @param {Function} [initializer] Function that will be called on initialization.\n\t * @class\n\t */\n\tvar Previewer = function (type, updater, supportedLanguages, initializer) {\n\t\tthis._elt = null;\n\t\tthis._type = type;\n\t\tthis._token = null;\n\t\tthis.updater = updater;\n\t\tthis._mouseout = this.mouseout.bind(this);\n\t\tthis.initializer = initializer;\n\n\t\tvar self = this;\n\n\t\tif (!supportedLanguages) {\n\t\t\tsupportedLanguages = ['*'];\n\t\t}\n\t\tif (!Array.isArray(supportedLanguages)) {\n\t\t\tsupportedLanguages = [supportedLanguages];\n\t\t}\n\t\tsupportedLanguages.forEach(function (lang) {\n\t\t\tif (typeof lang !== 'string') {\n\t\t\t\tlang = lang.lang;\n\t\t\t}\n\t\t\tif (!Previewer.byLanguages[lang]) {\n\t\t\t\tPreviewer.byLanguages[lang] = [];\n\t\t\t}\n\t\t\tif (Previewer.byLanguages[lang].indexOf(self) < 0) {\n\t\t\t\tPreviewer.byLanguages[lang].push(self);\n\t\t\t}\n\t\t});\n\t\tPreviewer.byType[type] = this;\n\t};\n\n\t/**\n\t * Creates the HTML element for the previewer.\n\t */\n\tPreviewer.prototype.init = function () {\n\t\tif (this._elt) {\n\t\t\treturn;\n\t\t}\n\t\tthis._elt = document.createElement('div');\n\t\tthis._elt.className = 'prism-previewer prism-previewer-' + this._type;\n\t\tdocument.body.appendChild(this._elt);\n\t\tif (this.initializer) {\n\t\t\tthis.initializer();\n\t\t}\n\t};\n\n\t/**\n\t * @param {Element} token\n\t * @returns {boolean}\n\t */\n\tPreviewer.prototype.isDisabled = function (token) {\n\t\tdo {\n\t\t\tif (token.hasAttribute && token.hasAttribute('data-previewers')) {\n\t\t\t\tvar previewers = token.getAttribute('data-previewers');\n\t\t\t\treturn (previewers || '').split(/\\s+/).indexOf(this._type) === -1;\n\t\t\t}\n\t\t} while ((token = token.parentNode));\n\t\treturn false;\n\t};\n\n\t/**\n\t * Checks the class name of each hovered element\n\t *\n\t * @param {Element} token\n\t */\n\tPreviewer.prototype.check = function (token) {\n\t\tif (token.classList.contains(TOKEN_CLASS) && this.isDisabled(token)) {\n\t\t\treturn;\n\t\t}\n\t\tdo {\n\t\t\tif (token.classList && token.classList.contains(TOKEN_CLASS) && token.classList.contains(this._type)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while ((token = token.parentNode));\n\n\t\tif (token && token !== this._token) {\n\t\t\tthis._token = token;\n\t\t\tthis.show();\n\t\t}\n\t};\n\n\t/**\n\t * Called on mouseout\n\t */\n\tPreviewer.prototype.mouseout = function () {\n\t\tthis._token.removeEventListener('mouseout', this._mouseout, false);\n\t\tthis._token = null;\n\t\tthis.hide();\n\t};\n\n\t/**\n\t * Shows the previewer positioned properly for the current token.\n\t */\n\tPreviewer.prototype.show = function () {\n\t\tif (!this._elt) {\n\t\t\tthis.init();\n\t\t}\n\t\tif (!this._token) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.updater.call(this._elt, this._token.textContent)) {\n\t\t\tthis._token.addEventListener('mouseout', this._mouseout, false);\n\n\t\t\tvar offset = getOffset(this._token);\n\t\t\tthis._elt.classList.add(ACTIVE_CLASS);\n\n\t\t\tif (offset.top - this._elt.offsetHeight > 0) {\n\t\t\t\tthis._elt.classList.remove(FLIPPED_CLASS);\n\t\t\t\tthis._elt.style.top = offset.top + 'px';\n\t\t\t\tthis._elt.style.bottom = '';\n\t\t\t} else {\n\t\t\t\tthis._elt.classList.add(FLIPPED_CLASS);\n\t\t\t\tthis._elt.style.bottom = offset.bottom + 'px';\n\t\t\t\tthis._elt.style.top = '';\n\t\t\t}\n\n\t\t\tthis._elt.style.left = offset.left + Math.min(200, offset.width / 2) + 'px';\n\t\t} else {\n\t\t\tthis.hide();\n\t\t}\n\t};\n\n\t/**\n\t * Hides the previewer.\n\t */\n\tPreviewer.prototype.hide = function () {\n\t\tthis._elt.classList.remove(ACTIVE_CLASS);\n\t};\n\n\t/**\n\t * Map of all registered previewers by language\n\t *\n\t * @type {{}}\n\t */\n\tPreviewer.byLanguages = {};\n\n\t/**\n\t * Map of all registered previewers by type\n\t *\n\t * @type {{}}\n\t */\n\tPreviewer.byType = {};\n\n\t/**\n\t * Initializes the mouseover event on the code block.\n\t *\n\t * @param {HTMLElement} elt The code block (env.element)\n\t * @param {string} lang The language (env.language)\n\t */\n\tPreviewer.initEvents = function (elt, lang) {\n\t\tvar previewers = [];\n\t\tif (Previewer.byLanguages[lang]) {\n\t\t\tpreviewers = previewers.concat(Previewer.byLanguages[lang]);\n\t\t}\n\t\tif (Previewer.byLanguages['*']) {\n\t\t\tpreviewers = previewers.concat(Previewer.byLanguages['*']);\n\t\t}\n\t\telt.addEventListener('mouseover', function (e) {\n\t\t\tvar target = e.target;\n\t\t\tpreviewers.forEach(function (previewer) {\n\t\t\t\tpreviewer.check(target);\n\t\t\t});\n\t\t}, false);\n\t};\n\tPrism.plugins.Previewer = Previewer;\n\n\tPrism.hooks.add('before-highlight', function (env) {\n\t\tfor (var previewer in previewers) {\n\t\t\tvar languages = previewers[previewer].languages;\n\t\t\tif (env.language && languages[env.language] && !languages[env.language].initialized) {\n\t\t\t\tvar lang = languages[env.language];\n\t\t\t\tif (!Array.isArray(lang)) {\n\t\t\t\t\tlang = [lang];\n\t\t\t\t}\n\t\t\t\tlang.forEach(function (lang) {\n\t\t\t\t\tvar before; var inside; var root; var skip;\n\t\t\t\t\tif (lang === true) {\n\t\t\t\t\t\tbefore = 'important';\n\t\t\t\t\t\tinside = env.language;\n\t\t\t\t\t\tlang = env.language;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbefore = lang.before || 'important';\n\t\t\t\t\t\tinside = lang.inside || lang.lang;\n\t\t\t\t\t\troot = lang.root || Prism.languages;\n\t\t\t\t\t\tskip = lang.skip;\n\t\t\t\t\t\tlang = env.language;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!skip && Prism.languages[lang]) {\n\t\t\t\t\t\tPrism.languages.insertBefore(inside, before, previewers[previewer].tokens, root);\n\t\t\t\t\t\tenv.grammar = Prism.languages[lang];\n\n\t\t\t\t\t\tlanguages[env.language] = { initialized: true };\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\t// Initialize the previewers only when needed\n\tPrism.hooks.add('after-highlight', function (env) {\n\t\tif (Previewer.byLanguages['*'] || Previewer.byLanguages[env.language]) {\n\t\t\tPreviewer.initEvents(env.element, env.language);\n\t\t}\n\t});\n\n\tfor (var previewer in previewers) {\n\t\tpreviewers[previewer].create();\n\t}\n\n}());\n\n(function () {\n\n\tif (typeof Prism === 'undefined') {\n\t\treturn;\n\t}\n\n\tvar assign = Object.assign || function (obj1, obj2) {\n\t\tfor (var name in obj2) {\n\t\t\tif (obj2.hasOwnProperty(name)) {\n\t\t\t\tobj1[name] = obj2[name];\n\t\t\t}\n\t\t}\n\t\treturn obj1;\n\t};\n\n\tfunction NormalizeWhitespace(defaults) {\n\t\tthis.defaults = assign({}, defaults);\n\t}\n\n\tfunction toCamelCase(value) {\n\t\treturn value.replace(/-(\\w)/g, function (match, firstChar) {\n\t\t\treturn firstChar.toUpperCase();\n\t\t});\n\t}\n\n\tfunction tabLen(str) {\n\t\tvar res = 0;\n\t\tfor (var i = 0; i < str.length; ++i) {\n\t\t\tif (str.charCodeAt(i) == '\\t'.charCodeAt(0)) {\n\t\t\t\tres += 3;\n\t\t\t}\n\t\t}\n\t\treturn str.length + res;\n\t}\n\n\tvar settingsConfig = {\n\t\t'remove-trailing': 'boolean',\n\t\t'remove-indent': 'boolean',\n\t\t'left-trim': 'boolean',\n\t\t'right-trim': 'boolean',\n\t\t'break-lines': 'number',\n\t\t'indent': 'number',\n\t\t'remove-initial-line-feed': 'boolean',\n\t\t'tabs-to-spaces': 'number',\n\t\t'spaces-to-tabs': 'number',\n\t};\n\n\tNormalizeWhitespace.prototype = {\n\t\tsetDefaults: function (defaults) {\n\t\t\tthis.defaults = assign(this.defaults, defaults);\n\t\t},\n\t\tnormalize: function (input, settings) {\n\t\t\tsettings = assign(this.defaults, settings);\n\n\t\t\tfor (var name in settings) {\n\t\t\t\tvar methodName = toCamelCase(name);\n\t\t\t\tif (name !== 'normalize' && methodName !== 'setDefaults' &&\n\t\t\t\t\tsettings[name] && this[methodName]) {\n\t\t\t\t\tinput = this[methodName].call(this, input, settings[name]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn input;\n\t\t},\n\n\t\t/*\n\t\t * Normalization methods\n\t\t */\n\t\tleftTrim: function (input) {\n\t\t\treturn input.replace(/^\\s+/, '');\n\t\t},\n\t\trightTrim: function (input) {\n\t\t\treturn input.replace(/\\s+$/, '');\n\t\t},\n\t\ttabsToSpaces: function (input, spaces) {\n\t\t\tspaces = spaces|0 || 4;\n\t\t\treturn input.replace(/\\t/g, new Array(++spaces).join(' '));\n\t\t},\n\t\tspacesToTabs: function (input, spaces) {\n\t\t\tspaces = spaces|0 || 4;\n\t\t\treturn input.replace(RegExp(' {' + spaces + '}', 'g'), '\\t');\n\t\t},\n\t\tremoveTrailing: function (input) {\n\t\t\treturn input.replace(/\\s*?$/gm, '');\n\t\t},\n\t\t// Support for deprecated plugin remove-initial-line-feed\n\t\tremoveInitialLineFeed: function (input) {\n\t\t\treturn input.replace(/^(?:\\r?\\n|\\r)/, '');\n\t\t},\n\t\tremoveIndent: function (input) {\n\t\t\tvar indents = input.match(/^[^\\S\\n\\r]*(?=\\S)/gm);\n\n\t\t\tif (!indents || !indents[0].length) {\n\t\t\t\treturn input;\n\t\t\t}\n\n\t\t\tindents.sort(function (a, b) { return a.length - b.length; });\n\n\t\t\tif (!indents[0].length) {\n\t\t\t\treturn input;\n\t\t\t}\n\n\t\t\treturn input.replace(RegExp('^' + indents[0], 'gm'), '');\n\t\t},\n\t\tindent: function (input, tabs) {\n\t\t\treturn input.replace(/^[^\\S\\n\\r]*(?=\\S)/gm, new Array(++tabs).join('\\t') + '$&');\n\t\t},\n\t\tbreakLines: function (input, characters) {\n\t\t\tcharacters = (characters === true) ? 80 : characters|0 || 80;\n\n\t\t\tvar lines = input.split('\\n');\n\t\t\tfor (var i = 0; i < lines.length; ++i) {\n\t\t\t\tif (tabLen(lines[i]) <= characters) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar line = lines[i].split(/(\\s+)/g);\n\t\t\t\tvar len = 0;\n\n\t\t\t\tfor (var j = 0; j < line.length; ++j) {\n\t\t\t\t\tvar tl = tabLen(line[j]);\n\t\t\t\t\tlen += tl;\n\t\t\t\t\tif (len > characters) {\n\t\t\t\t\t\tline[j] = '\\n' + line[j];\n\t\t\t\t\t\tlen = tl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlines[i] = line.join('');\n\t\t\t}\n\t\t\treturn lines.join('\\n');\n\t\t}\n\t};\n\n\t// Support node modules\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = NormalizeWhitespace;\n\t}\n\nPrism.plugins.NormalizeWhitespace = new NormalizeWhitespace({\n    \"remove-trailing\": true,\n    \"remove-indent\": true,\n    \"left-trim\": true,\n    \"right-trim\": true,\n    indent: 4,\n  });\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar Normalizer = Prism.plugins.NormalizeWhitespace;\n\n\t\t// Check settings\n\t\tif (env.settings && env.settings['whitespace-normalization'] === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check classes\n\t\tif (!Prism.util.isActive(env.element, 'whitespace-normalization', true)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Simple mode if there is no env.element\n\t\tif ((!env.element || !env.element.parentNode) && env.code) {\n\t\t\tenv.code = Normalizer.normalize(env.code, env.settings);\n\t\t\treturn;\n\t\t}\n\n\t\t// Normal mode\n\t\tvar pre = env.element.parentNode;\n\t\tif (!env.code || !pre || pre.nodeName.toLowerCase() !== 'pre') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (env.settings == null) { env.settings = {}; }\n\n\t\t// Read settings from 'data-' attributes\n\t\tfor (var key in settingsConfig) {\n\t\t\tif (Object.hasOwnProperty.call(settingsConfig, key)) {\n\t\t\t\tvar settingType = settingsConfig[key];\n\t\t\t\tif (pre.hasAttribute('data-' + key)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar value = JSON.parse(pre.getAttribute('data-' + key) || 'true');\n\t\t\t\t\t\tif (typeof value === settingType) {\n\t\t\t\t\t\t\tenv.settings[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_error) {\n\t\t\t\t\t\t// ignore error\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar children = pre.childNodes;\n\t\tvar before = '';\n\t\tvar after = '';\n\t\tvar codeFound = false;\n\n\t\t// Move surrounding whitespace from the <pre> tag into the <code> tag\n\t\tfor (var i = 0; i < children.length; ++i) {\n\t\t\tvar node = children[i];\n\n\t\t\tif (node == env.element) {\n\t\t\t\tcodeFound = true;\n\t\t\t} else if (node.nodeName === '#text') {\n\t\t\t\tif (codeFound) {\n\t\t\t\t\tafter += node.nodeValue;\n\t\t\t\t} else {\n\t\t\t\t\tbefore += node.nodeValue;\n\t\t\t\t}\n\n\t\t\t\tpre.removeChild(node);\n\t\t\t\t--i;\n\t\t\t}\n\t\t}\n\n\t\tif (!env.element.children.length || !Prism.plugins.KeepMarkup) {\n\t\t\tenv.code = before + env.code + after;\n\t\t\tenv.code = Normalizer.normalize(env.code, env.settings);\n\t\t} else {\n\t\t\t// Preserve markup for keep-markup plugin\n\t\t\tvar html = before + env.element.innerHTML + after;\n\t\t\tenv.element.innerHTML = Normalizer.normalize(html, env.settings);\n\t\t\tenv.code = env.element.textContent;\n\t\t}\n\t});\n\n}());\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\tvar callbacks = [];\n\tvar map = {};\n\tvar noop = function () {};\n\n\tPrism.plugins.toolbar = {};\n\n\t/**\n\t * @typedef ButtonOptions\n\t * @property {string} text The text displayed.\n\t * @property {string} [url] The URL of the link which will be created.\n\t * @property {Function} [onClick] The event listener for the `click` event of the created button.\n\t * @property {string} [className] The class attribute to include with element.\n\t */\n\n\t/**\n\t * Register a button callback with the toolbar.\n\t *\n\t * @param {string} key\n\t * @param {ButtonOptions|Function} opts\n\t */\n\tvar registerButton = Prism.plugins.toolbar.registerButton = function (key, opts) {\n\t\tvar callback;\n\n\t\tif (typeof opts === 'function') {\n\t\t\tcallback = opts;\n\t\t} else {\n\t\t\tcallback = function (env) {\n\t\t\t\tvar element;\n\n\t\t\t\tif (typeof opts.onClick === 'function') {\n\t\t\t\t\telement = document.createElement('button');\n\t\t\t\t\telement.type = 'button';\n\t\t\t\t\telement.addEventListener('click', function () {\n\t\t\t\t\t\topts.onClick.call(this, env);\n\t\t\t\t\t});\n\t\t\t\t} else if (typeof opts.url === 'string') {\n\t\t\t\t\telement = document.createElement('a');\n\t\t\t\t\telement.href = opts.url;\n\t\t\t\t} else {\n\t\t\t\t\telement = document.createElement('span');\n\t\t\t\t}\n\n\t\t\t\tif (opts.className) {\n\t\t\t\t\telement.classList.add(opts.className);\n\t\t\t\t}\n\n\t\t\t\telement.textContent = opts.text;\n\n\t\t\t\treturn element;\n\t\t\t};\n\t\t}\n\n\t\tif (key in map) {\n\t\t\tconsole.warn('There is a button with the key \"' + key + '\" registered already.');\n\t\t\treturn;\n\t\t}\n\n\t\tcallbacks.push(map[key] = callback);\n\t};\n\n\t/**\n\t * Returns the callback order of the given element.\n\t *\n\t * @param {HTMLElement} element\n\t * @returns {string[] | undefined}\n\t */\n\tfunction getOrder(element) {\n\t\twhile (element) {\n\t\t\tvar order = element.getAttribute('data-toolbar-order');\n\t\t\tif (order != null) {\n\t\t\t\torder = order.trim();\n\t\t\t\tif (order.length) {\n\t\t\t\t\treturn order.split(/\\s*,\\s*/g);\n\t\t\t\t} else {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}\n\t\t\telement = element.parentElement;\n\t\t}\n\t}\n\n\t/**\n\t * Post-highlight Prism hook callback.\n\t *\n\t * @param env\n\t */\n\tvar hook = Prism.plugins.toolbar.hook = function (env) {\n\t\t// Check if inline or actual code block (credit to line-numbers plugin)\n\t\tvar pre = env.element.parentNode;\n\t\tif (!pre || !/pre/i.test(pre.nodeName)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Autoloader rehighlights, so only do this once.\n\t\tif (pre.parentNode.classList.contains('code-toolbar')) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create wrapper for <pre> to prevent scrolling toolbar with content\n\t\tvar wrapper = document.createElement('div');\n\t\twrapper.classList.add('code-toolbar');\n\t\tpre.parentNode.insertBefore(wrapper, pre);\n\t\twrapper.appendChild(pre);\n\n\t\t// Setup the toolbar\n\t\tvar toolbar = document.createElement('div');\n\t\ttoolbar.classList.add('toolbar');\n\n\t\t// order callbacks\n\t\tvar elementCallbacks = callbacks;\n\t\tvar order = getOrder(env.element);\n\t\tif (order) {\n\t\t\telementCallbacks = order.map(function (key) {\n\t\t\t\treturn map[key] || noop;\n\t\t\t});\n\t\t}\n\n\t\telementCallbacks.forEach(function (callback) {\n\t\t\tvar element = callback(env);\n\n\t\t\tif (!element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar item = document.createElement('div');\n\t\t\titem.classList.add('toolbar-item');\n\n\t\t\titem.appendChild(element);\n\t\t\ttoolbar.appendChild(item);\n\t\t});\n\n\t\t// Add our toolbar to the currently created wrapper of <pre> tag\n\t\twrapper.appendChild(toolbar);\n\t};\n\n\tregisterButton('label', function (env) {\n\t\tvar pre = env.element.parentNode;\n\t\tif (!pre || !/pre/i.test(pre.nodeName)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!pre.hasAttribute('data-label')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar element; var template;\n\t\tvar text = pre.getAttribute('data-label');\n\t\ttry {\n\t\t\t// Any normal text will blow up this selector.\n\t\t\ttemplate = document.querySelector('template#' + text);\n\t\t} catch (e) { /* noop */ }\n\n\t\tif (template) {\n\t\t\telement = template.content;\n\t\t} else {\n\t\t\tif (pre.hasAttribute('data-url')) {\n\t\t\t\telement = document.createElement('a');\n\t\t\t\telement.href = pre.getAttribute('data-url');\n\t\t\t} else {\n\t\t\t\telement = document.createElement('span');\n\t\t\t}\n\n\t\t\telement.textContent = text;\n\t\t}\n\n\t\treturn element;\n\t});\n\n\t/**\n\t * Register the toolbar with Prism.\n\t */\n\tPrism.hooks.add('complete', hook);\n}());\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\tif (!Prism.plugins.toolbar) {\n\t\tconsole.warn('Copy to Clipboard plugin loaded before Toolbar plugin.');\n\n\t\treturn;\n\t}\n\n\t/**\n\t * When the given elements is clicked by the user, the given text will be copied to clipboard.\n\t *\n\t * @param {HTMLElement} element\n\t * @param {CopyInfo} copyInfo\n\t *\n\t * @typedef CopyInfo\n\t * @property {() => string} getText\n\t * @property {() => void} success\n\t * @property {(reason: unknown) => void} error\n\t */\n\tfunction registerClipboard(element, copyInfo) {\n\t\telement.addEventListener('click', function () {\n\t\t\tcopyTextToClipboard(copyInfo);\n\t\t});\n\t}\n\n\t// https://stackoverflow.com/a/30810322/7595472\n\n\t/** @param {CopyInfo} copyInfo */\n\tfunction fallbackCopyTextToClipboard(copyInfo) {\n\t\tvar textArea = document.createElement('textarea');\n\t\ttextArea.value = copyInfo.getText();\n\n\t\t// Avoid scrolling to bottom\n\t\ttextArea.style.top = '0';\n\t\ttextArea.style.left = '0';\n\t\ttextArea.style.position = 'fixed';\n\n\t\tdocument.body.appendChild(textArea);\n\t\ttextArea.focus();\n\t\ttextArea.select();\n\n\t\ttry {\n\t\t\tvar successful = document.execCommand('copy');\n\t\t\tsetTimeout(function () {\n\t\t\t\tif (successful) {\n\t\t\t\t\tcopyInfo.success();\n\t\t\t\t} else {\n\t\t\t\t\tcopyInfo.error();\n\t\t\t\t}\n\t\t\t}, 1);\n\t\t} catch (err) {\n\t\t\tsetTimeout(function () {\n\t\t\t\tcopyInfo.error(err);\n\t\t\t}, 1);\n\t\t}\n\n\t\tdocument.body.removeChild(textArea);\n\t}\n\t/** @param {CopyInfo} copyInfo */\n\tfunction copyTextToClipboard(copyInfo) {\n\t\tif (navigator.clipboard) {\n\t\t\tnavigator.clipboard.writeText(copyInfo.getText()).then(copyInfo.success, function () {\n\t\t\t\t// try the fallback in case `writeText` didn't work\n\t\t\t\tfallbackCopyTextToClipboard(copyInfo);\n\t\t\t});\n\t\t} else {\n\t\t\tfallbackCopyTextToClipboard(copyInfo);\n\t\t}\n\t}\n\n\t/**\n\t * Selects the text content of the given element.\n\t *\n\t * @param {Element} element\n\t */\n\tfunction selectElementText(element) {\n\t\t// https://stackoverflow.com/a/20079910/7595472\n\t\twindow.getSelection().selectAllChildren(element);\n\t}\n\n\t/**\n\t * Traverses up the DOM tree to find data attributes that override the default plugin settings.\n\t *\n\t * @param {Element} startElement An element to start from.\n\t * @returns {Settings} The plugin settings.\n\t * @typedef {Record<\"copy\" | \"copy-error\" | \"copy-success\" | \"copy-timeout\", string | number>} Settings\n\t */\n\tfunction getSettings(startElement) {\n\t\t/** @type {Settings} */\n\t\tvar settings = {\n\t\t\t'copy': 'Copy',\n\t\t\t'copy-error': 'Press Ctrl+C to copy',\n\t\t\t'copy-success': 'Copied!',\n\t\t\t'copy-timeout': 5000\n\t\t};\n\n\t\tvar prefix = 'data-prismjs-';\n\t\tfor (var key in settings) {\n\t\t\tvar attr = prefix + key;\n\t\t\tvar element = startElement;\n\t\t\twhile (element && !element.hasAttribute(attr)) {\n\t\t\t\telement = element.parentElement;\n\t\t\t}\n\t\t\tif (element) {\n\t\t\t\tsettings[key] = element.getAttribute(attr);\n\t\t\t}\n\t\t}\n\t\treturn settings;\n\t}\n\n\tPrism.plugins.toolbar.registerButton('copy-to-clipboard', function (env) {\n\t\tvar element = env.element;\n\n\t\tvar settings = getSettings(element);\n\n\t\tvar linkCopy = document.createElement('button');\n\t\tlinkCopy.className = 'copy-to-clipboard-button';\n\t\tlinkCopy.setAttribute('type', 'button');\n\t\tvar linkSpan = document.createElement('span');\n\t\tlinkCopy.appendChild(linkSpan);\n\n\t\tsetState('copy');\n\n\t\tregisterClipboard(linkCopy, {\n\t\t\tgetText: function () {\n\t\t\t\treturn element.textContent;\n\t\t\t},\n\t\t\tsuccess: function () {\n\t\t\t\tsetState('copy-success');\n\n\t\t\t\tresetText();\n\t\t\t},\n\t\t\terror: function () {\n\t\t\t\tsetState('copy-error');\n\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tselectElementText(element);\n\t\t\t\t}, 1);\n\n\t\t\t\tresetText();\n\t\t\t}\n\t\t});\n\n\t\treturn linkCopy;\n\n\t\tfunction resetText() {\n\t\t\tsetTimeout(function () { setState('copy'); }, settings['copy-timeout']);\n\t\t}\n\n\t\t/** @param {\"copy\" | \"copy-error\" | \"copy-success\"} state */\n\t\tfunction setState(state) {\n\t\t\tlinkSpan.textContent = settings[state];\n\t\t\tlinkCopy.setAttribute('data-copy-state', state);\n\t\t}\n\t});\n}());\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\tfunction mapClassName(name) {\n\t\tvar customClass = Prism.plugins.customClass;\n\t\tif (customClass) {\n\t\t\treturn customClass.apply(name, 'none');\n\t\t} else {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\tvar PARTNER = {\n\t\t'(': ')',\n\t\t'[': ']',\n\t\t'{': '}',\n\t};\n\n\t// The names for brace types.\n\t// These names have two purposes: 1) they can be used for styling and 2) they are used to pair braces. Only braces\n\t// of the same type are paired.\n\tvar NAMES = {\n\t\t'(': 'brace-round',\n\t\t'[': 'brace-square',\n\t\t'{': 'brace-curly',\n\t};\n\n\t// A map for brace aliases.\n\t// This is useful for when some braces have a prefix/suffix as part of the punctuation token.\n\tvar BRACE_ALIAS_MAP = {\n\t\t'${': '{', // JS template punctuation (e.g. `foo ${bar + 1}`)\n\t};\n\n\tvar LEVEL_WARP = 12;\n\n\tvar pairIdCounter = 0;\n\n\tvar BRACE_ID_PATTERN = /^(pair-\\d+-)(close|open)$/;\n\n\t/**\n\t * Returns the brace partner given one brace of a brace pair.\n\t *\n\t * @param {HTMLElement} brace\n\t * @returns {HTMLElement}\n\t */\n\tfunction getPartnerBrace(brace) {\n\t\tvar match = BRACE_ID_PATTERN.exec(brace.id);\n\t\treturn document.querySelector('#' + match[1] + (match[2] == 'open' ? 'close' : 'open'));\n\t}\n\n\t/**\n\t * @this {HTMLElement}\n\t */\n\tfunction hoverBrace() {\n\t\tif (!Prism.util.isActive(this, 'brace-hover', true)) {\n\t\t\treturn;\n\t\t}\n\n\t\t[this, getPartnerBrace(this)].forEach(function (e) {\n\t\t\te.classList.add(mapClassName('brace-hover'));\n\t\t});\n\t}\n\t/**\n\t * @this {HTMLElement}\n\t */\n\tfunction leaveBrace() {\n\t\t[this, getPartnerBrace(this)].forEach(function (e) {\n\t\t\te.classList.remove(mapClassName('brace-hover'));\n\t\t});\n\t}\n\t/**\n\t * @this {HTMLElement}\n\t */\n\tfunction clickBrace() {\n\t\tif (!Prism.util.isActive(this, 'brace-select', true)) {\n\t\t\treturn;\n\t\t}\n\n\t\t[this, getPartnerBrace(this)].forEach(function (e) {\n\t\t\te.classList.add(mapClassName('brace-selected'));\n\t\t});\n\t}\n\n\tPrism.hooks.add('complete', function (env) {\n\n\t\t/** @type {HTMLElement} */\n\t\tvar code = env.element;\n\t\tvar pre = code.parentElement;\n\n\t\tif (!pre || pre.tagName != 'PRE') {\n\t\t\treturn;\n\t\t}\n\n\t\t// find the braces to match\n\t\t/** @type {string[]} */\n\t\tvar toMatch = [];\n\t\tif (Prism.util.isActive(code, 'match-braces')) {\n\t\t\ttoMatch.push('(', '[', '{');\n\t\t}\n\n\t\tif (toMatch.length == 0) {\n\t\t\t// nothing to match\n\t\t\treturn;\n\t\t}\n\n\t\tif (!pre.__listenerAdded) {\n\t\t\t// code blocks might be highlighted more than once\n\t\t\tpre.addEventListener('mousedown', function removeBraceSelected() {\n\t\t\t\t// the code element might have been replaced\n\t\t\t\tvar code = pre.querySelector('code');\n\t\t\t\tvar className = mapClassName('brace-selected');\n\t\t\t\tArray.prototype.slice.call(code.querySelectorAll('.' + className)).forEach(function (e) {\n\t\t\t\t\te.classList.remove(className);\n\t\t\t\t});\n\t\t\t});\n\t\t\tObject.defineProperty(pre, '__listenerAdded', { value: true });\n\t\t}\n\n\t\t/** @type {HTMLSpanElement[]} */\n\t\tvar punctuation = Array.prototype.slice.call(\n\t\t\tcode.querySelectorAll('span.' + mapClassName('token') + '.' + mapClassName('punctuation'))\n\t\t);\n\n\t\t/** @type {{ index: number, open: boolean, element: HTMLElement }[]} */\n\t\tvar allBraces = [];\n\n\t\ttoMatch.forEach(function (open) {\n\t\t\tvar close = PARTNER[open];\n\t\t\tvar name = mapClassName(NAMES[open]);\n\n\t\t\t/** @type {[number, number][]} */\n\t\t\tvar pairs = [];\n\t\t\t/** @type {number[]} */\n\t\t\tvar openStack = [];\n\n\t\t\tfor (var i = 0; i < punctuation.length; i++) {\n\t\t\t\tvar element = punctuation[i];\n\t\t\t\tif (element.childElementCount == 0) {\n\t\t\t\t\tvar text = element.textContent;\n\t\t\t\t\ttext = BRACE_ALIAS_MAP[text] || text;\n\t\t\t\t\tif (text === open) {\n\t\t\t\t\t\tallBraces.push({ index: i, open: true, element: element });\n\t\t\t\t\t\telement.classList.add(name);\n\t\t\t\t\t\telement.classList.add(mapClassName('brace-open'));\n\t\t\t\t\t\topenStack.push(i);\n\t\t\t\t\t} else if (text === close) {\n\t\t\t\t\t\tallBraces.push({ index: i, open: false, element: element });\n\t\t\t\t\t\telement.classList.add(name);\n\t\t\t\t\t\telement.classList.add(mapClassName('brace-close'));\n\t\t\t\t\t\tif (openStack.length) {\n\t\t\t\t\t\t\tpairs.push([i, openStack.pop()]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpairs.forEach(function (pair) {\n\t\t\t\tvar pairId = 'pair-' + (pairIdCounter++) + '-';\n\n\t\t\t\tvar opening = punctuation[pair[0]];\n\t\t\t\tvar closing = punctuation[pair[1]];\n\n\t\t\t\topening.id = pairId + 'open';\n\t\t\t\tclosing.id = pairId + 'close';\n\n\t\t\t\t[opening, closing].forEach(function (e) {\n\t\t\t\t\te.addEventListener('mouseenter', hoverBrace);\n\t\t\t\t\te.addEventListener('mouseleave', leaveBrace);\n\t\t\t\t\te.addEventListener('click', clickBrace);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tvar level = 0;\n\t\tallBraces.sort(function (a, b) { return a.index - b.index; });\n\t\tallBraces.forEach(function (brace) {\n\t\t\tif (brace.open) {\n\t\t\t\tbrace.element.classList.add(mapClassName('brace-level-' + (level % LEVEL_WARP + 1)));\n\t\t\t\tlevel++;\n\t\t\t} else {\n\t\t\t\tlevel = Math.max(0, level - 1);\n\t\t\t\tbrace.element.classList.add(mapClassName('brace-level-' + (level % LEVEL_WARP + 1)));\n\t\t\t}\n\t\t});\n\t});\n\n}());\n"],"names":["string","markup","specialEscape","escape","rangeChar","range","groupName","Prism","_self","lang","uniqueId","plainTextGrammar","_","manual","disableWorkerMessageHandler","util","encode","tokens","Token","type","content","alias","Array","isArray","map","replace","o","Object","prototype","toString","call","slice","objId","obj","defineProperty","value","clone","deepClone","visited","id","key","hasOwnProperty","forEach","v","i","getLanguage","element","m","exec","className","toLowerCase","parentElement","setLanguage","language","RegExp","classList","add","currentScript","document","Error","err","src","stack","scripts","getElementsByTagName","isActive","defaultActivation","no","contains","languages","plain","plaintext","text","txt","extend","redef","insertBefore","inside","before","insert","root","grammar","ret","token","newToken","old","DFS","callback","property","propertyType","plugins","highlightAll","async","highlightAllUnder","container","env","selector","hooks","run","elements","apply","querySelectorAll","highlightElement","parent","nodeName","code","textContent","insertHighlightedCode","highlightedCode","innerHTML","hasAttribute","setAttribute","Worker","worker","filename","onmessage","evt","data","postMessage","JSON","stringify","immediateClose","highlight","tokenize","rest","tokenList","LinkedList","addAfter","head","matchGrammar","startNode","startPos","rematch","patterns","j","length","cause","patternObj","lookbehind","greedy","pattern","global","flags","match","source","currentNode","next","pos","tail","reach","str","removeCount","matchPattern","index","from","to","p","k","matchStr","after","removeFrom","prev","removeRange","list","node","count","nestedRematch","toArray","array","push","all","name","callbacks","matchedStr","lastIndex","lookbehindLength","newNode","s","e","tag","classes","attributes","aliases","join","addEventListener","message","parse","close","script","highlightAutomaticallyCallback","readyState","defer","window","requestAnimationFrame","setTimeout","WorkerGlobalScope","self","module","exports","tagName","includedCdataInside","def","attrName","html","mathml","svg","xml","ssml","atom","rss","css","addInlined","addAttribute","clike","javascript","regex","js","selectorInside","unit","number","git","scss","PLUGIN_NAME","NEW_LINE_EXP","config","lineNumbers","getLine","lineNumberRows","querySelector","lineNumberStart","parseInt","getAttribute","lineNumberEnd","children","lineIndex","resize","resizeElements","assumeViewportIndependence","lastWidth","undefined","innerWidth","lineNumbersWrapper","pre","parentNode","test","remove","lines","linesNum","createElement","style","counterReset","appendChild","filter","whiteSpace","codeStyles","getComputedStyle","currentStyle","infos","codeElement","lineNumberSizer","codeLines","split","display","oneLinerHeight","getBoundingClientRect","height","lineHeights","sizer","Boolean","info","line","childIndex","wrapper","lineNumber","Function","bind","cache","convertToW3CLinearGradient","convertToW3CRadialGradient","convertToW3CGradient","previewers","create","prefix","func","values","angle","shift","indexOf","parseFloat","Math","PI","position","shape","size","shapeSizeParts","gradient","parts","Previewer","firstChild","backgroundImage","_elt","sass","stylus","max","percentage","num","strokeDasharray","abs","backgroundColor","concat","animationDuration","getOffset","elementBounds","left","top","documentBounds","documentElement","right","width","bottom","innerHeight","TOKEN_CLASS","ACTIVE_CLASS","FLIPPED_CLASS","updater","supportedLanguages","initializer","_type","_token","_mouseout","mouseout","_$self","byLanguages","byType","previewer","init","body","isDisabled","check","show","removeEventListener","hide","offset","offsetHeight","min","initEvents","elt","target","initialized","skip","assign","obj1","obj2","settingsConfig","NormalizeWhitespace","setDefaults","defaults","normalize","input","settings","methodName","firstChar","toUpperCase","leftTrim","rightTrim","tabsToSpaces","spaces","spacesToTabs","removeTrailing","removeInitialLineFeed","removeIndent","indents","sort","a","b","indent","tabs","breakLines","characters","tabLen","len","tl","Normalizer","settingType","Symbol","constructor","_error","childNodes","codeFound","nodeValue","removeChild","KeepMarkup","res","charCodeAt","noop","toolbar","registerButton","opts","onClick","url","href","console","warn","hook","elementCallbacks","order","getOrder","trim","item","template","getSettings","startElement","attr","linkCopy","linkSpan","setState","registerClipboard","copyInfo","navigator","clipboard","writeText","getText","then","success","fallbackCopyTextToClipboard","resetText","error","getSelection","selectAllChildren","state","textArea","focus","select","successful","execCommand","PARTNER","NAMES","BRACE_ALIAS_MAP","pairIdCounter","BRACE_ID_PATTERN","toMatch","__listenerAdded","mapClassName","punctuation","allBraces","open","pairs","openStack","childElementCount","pop","pair","pairId","opening","closing","hoverBrace","leaveBrace","clickBrace","level","brace","customClass","getPartnerBrace"],"version":3,"file":"css--01-grid.554c191d.js.map"}